#
# Bug#35842412 WHERE NOT IN with subquery is much slower on 8.1 than 5.7
#
CREATE TABLE t1( b_id INTEGER NOT NULL PRIMARY KEY AUTO_INCREMENT,
val VARCHAR(100) NOT NULL, val_n VARCHAR(100),
KEY ix_val (val, b_id), KEY ix_val_n (val_n, b_id));
CREATE TABLE t2( a_id INTEGER NOT NULL PRIMARY KEY AUTO_INCREMENT,
val VARCHAR(100) NOT NULL, val_n VARCHAR(100),
UNIQUE KEY ix_val (val), UNIQUE KEY ix_val_n (val_n));
INSERT INTO t1(val, val_n)
WITH RECURSIVE DataSource(num, c1, c2) AS (
SELECT 1, lpad(1,25,'0'), lpad(1,25,'0')
UNION ALL
SELECT num + 1, lpad(mod(num+1,30),25,'0'),
lpad(ELT(num%400 != 0, mod(num+1,30)), 25, '0')
FROM DataSource
WHERE num < 1000
)
SELECT c1, c2 from DataSource;
INSERT INTO t2(val, val_n)
WITH RECURSIVE DataSource(num, c1, c2) AS (
SELECT 1, lpad(1,25,'0'), lpad(1,25,'0')
UNION ALL
SELECT num + 1, lpad(num+1,25,'0'), lpad(ELT(num%13 != 0, num+1), 25, '0')
FROM DataSource
WHERE num < 30
)
SELECT c1, c2 from DataSource;
ANALYZE TABLE t1, t2;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
test.t2	analyze	status	OK
# Should use group skip scan on t1
EXPLAIN FORMAT=TREE SELECT DISTINCT val FROM t1 WHERE EXISTS
(SELECT * FROM t2 WHERE t2.val = t1.val);
EXPLAIN
-> Nested loop inner join  (rows=31)
    -> Covering index skip scan for deduplication on t1 using ix_val  (rows=31)
    -> Single-row covering index lookup on t2 using ix_val (val=t1.val)  (rows=1)

Warnings:
Note	1276	Field or reference 'test.t1.val' of SELECT #2 was resolved in SELECT #1
SELECT DISTINCT val FROM t1 WHERE EXISTS
(SELECT * FROM t2 WHERE t2.val = t1.val);
val
0000000000000000000000001
0000000000000000000000002
0000000000000000000000003
0000000000000000000000004
0000000000000000000000005
0000000000000000000000006
0000000000000000000000007
0000000000000000000000008
0000000000000000000000009
0000000000000000000000010
0000000000000000000000011
0000000000000000000000012
0000000000000000000000013
0000000000000000000000014
0000000000000000000000015
0000000000000000000000016
0000000000000000000000017
0000000000000000000000018
0000000000000000000000019
0000000000000000000000020
0000000000000000000000021
0000000000000000000000022
0000000000000000000000023
0000000000000000000000024
0000000000000000000000025
0000000000000000000000026
0000000000000000000000027
0000000000000000000000028
0000000000000000000000029
EXPLAIN FORMAT=TREE SELECT val FROM t1 WHERE EXISTS
(SELECT * FROM t2 WHERE t2.val = t1.val) GROUP BY val;
EXPLAIN
-> Nested loop inner join  (rows=31)
    -> Covering index skip scan for deduplication on t1 using ix_val  (rows=31)
    -> Single-row covering index lookup on t2 using ix_val (val=t1.val)  (rows=1)

Warnings:
Note	1276	Field or reference 'test.t1.val' of SELECT #2 was resolved in SELECT #1
SELECT val FROM t1 WHERE EXISTS
(SELECT * FROM t2 WHERE t2.val = t1.val) GROUP BY val;
val
0000000000000000000000001
0000000000000000000000002
0000000000000000000000003
0000000000000000000000004
0000000000000000000000005
0000000000000000000000006
0000000000000000000000007
0000000000000000000000008
0000000000000000000000009
0000000000000000000000010
0000000000000000000000011
0000000000000000000000012
0000000000000000000000013
0000000000000000000000014
0000000000000000000000015
0000000000000000000000016
0000000000000000000000017
0000000000000000000000018
0000000000000000000000019
0000000000000000000000020
0000000000000000000000021
0000000000000000000000022
0000000000000000000000023
0000000000000000000000024
0000000000000000000000025
0000000000000000000000026
0000000000000000000000027
0000000000000000000000028
0000000000000000000000029
EXPLAIN FORMAT=TREE SELECT DISTINCT val FROM t1 WHERE val IN (SELECT val FROM t2);
EXPLAIN
-> Nested loop inner join  (rows=31)
    -> Covering index skip scan for deduplication on t1 using ix_val  (rows=31)
    -> Single-row covering index lookup on t2 using ix_val (val=t1.val)  (rows=1)

SELECT DISTINCT val FROM t1 WHERE val IN (SELECT val FROM t2);
val
0000000000000000000000001
0000000000000000000000002
0000000000000000000000003
0000000000000000000000004
0000000000000000000000005
0000000000000000000000006
0000000000000000000000007
0000000000000000000000008
0000000000000000000000009
0000000000000000000000010
0000000000000000000000011
0000000000000000000000012
0000000000000000000000013
0000000000000000000000014
0000000000000000000000015
0000000000000000000000016
0000000000000000000000017
0000000000000000000000018
0000000000000000000000019
0000000000000000000000020
0000000000000000000000021
0000000000000000000000022
0000000000000000000000023
0000000000000000000000024
0000000000000000000000025
0000000000000000000000026
0000000000000000000000027
0000000000000000000000028
0000000000000000000000029
EXPLAIN FORMAT=TREE SELECT DISTINCT val FROM t1 WHERE val IN
(SELECT val FROM t2 WHERE t2.val = t1.val);
EXPLAIN
-> Nested loop inner join  (rows=31)
    -> Covering index skip scan for deduplication on t1 using ix_val  (rows=31)
    -> Single-row covering index lookup on t2 using ix_val (val=t1.val)  (rows=1)

Warnings:
Note	1276	Field or reference 'test.t1.val' of SELECT #2 was resolved in SELECT #1
SELECT DISTINCT val FROM t1 WHERE val IN
(SELECT val FROM t2 WHERE t2.val = t1.val);
val
0000000000000000000000001
0000000000000000000000002
0000000000000000000000003
0000000000000000000000004
0000000000000000000000005
0000000000000000000000006
0000000000000000000000007
0000000000000000000000008
0000000000000000000000009
0000000000000000000000010
0000000000000000000000011
0000000000000000000000012
0000000000000000000000013
0000000000000000000000014
0000000000000000000000015
0000000000000000000000016
0000000000000000000000017
0000000000000000000000018
0000000000000000000000019
0000000000000000000000020
0000000000000000000000021
0000000000000000000000022
0000000000000000000000023
0000000000000000000000024
0000000000000000000000025
0000000000000000000000026
0000000000000000000000027
0000000000000000000000028
0000000000000000000000029
EXPLAIN FORMAT=TREE SELECT val FROM t1 WHERE val IN (SELECT val FROM t2 ) GROUP BY val;
EXPLAIN
-> Nested loop inner join  (rows=31)
    -> Covering index skip scan for deduplication on t1 using ix_val  (rows=31)
    -> Single-row covering index lookup on t2 using ix_val (val=t1.val)  (rows=1)

SELECT val FROM t1 WHERE val IN (SELECT val FROM t2 ) GROUP BY val;
val
0000000000000000000000001
0000000000000000000000002
0000000000000000000000003
0000000000000000000000004
0000000000000000000000005
0000000000000000000000006
0000000000000000000000007
0000000000000000000000008
0000000000000000000000009
0000000000000000000000010
0000000000000000000000011
0000000000000000000000012
0000000000000000000000013
0000000000000000000000014
0000000000000000000000015
0000000000000000000000016
0000000000000000000000017
0000000000000000000000018
0000000000000000000000019
0000000000000000000000020
0000000000000000000000021
0000000000000000000000022
0000000000000000000000023
0000000000000000000000024
0000000000000000000000025
0000000000000000000000026
0000000000000000000000027
0000000000000000000000028
0000000000000000000000029
EXPLAIN FORMAT=TREE SELECT val FROM t1 WHERE val IN
(SELECT val FROM t2 WHERE t2.val = t1.val ) GROUP BY val;
EXPLAIN
-> Nested loop inner join  (rows=31)
    -> Covering index skip scan for deduplication on t1 using ix_val  (rows=31)
    -> Single-row covering index lookup on t2 using ix_val (val=t1.val)  (rows=1)

Warnings:
Note	1276	Field or reference 'test.t1.val' of SELECT #2 was resolved in SELECT #1
SELECT val FROM t1 WHERE val IN
(SELECT val FROM t2 WHERE t2.val = t1.val ) GROUP BY val;
val
0000000000000000000000001
0000000000000000000000002
0000000000000000000000003
0000000000000000000000004
0000000000000000000000005
0000000000000000000000006
0000000000000000000000007
0000000000000000000000008
0000000000000000000000009
0000000000000000000000010
0000000000000000000000011
0000000000000000000000012
0000000000000000000000013
0000000000000000000000014
0000000000000000000000015
0000000000000000000000016
0000000000000000000000017
0000000000000000000000018
0000000000000000000000019
0000000000000000000000020
0000000000000000000000021
0000000000000000000000022
0000000000000000000000023
0000000000000000000000024
0000000000000000000000025
0000000000000000000000026
0000000000000000000000027
0000000000000000000000028
0000000000000000000000029
EXPLAIN FORMAT=TREE SELECT DISTINCT val FROM t1 WHERE NOT EXISTS
(SELECT * FROM t2 WHERE val = 'asd');
EXPLAIN
-> Covering index skip scan for deduplication on t1 using ix_val  (rows=31)

SELECT DISTINCT val FROM t1 WHERE NOT EXISTS
(SELECT * FROM t2 WHERE val = 'asd');
val
0000000000000000000000000
0000000000000000000000001
0000000000000000000000002
0000000000000000000000003
0000000000000000000000004
0000000000000000000000005
0000000000000000000000006
0000000000000000000000007
0000000000000000000000008
0000000000000000000000009
0000000000000000000000010
0000000000000000000000011
0000000000000000000000012
0000000000000000000000013
0000000000000000000000014
0000000000000000000000015
0000000000000000000000016
0000000000000000000000017
0000000000000000000000018
0000000000000000000000019
0000000000000000000000020
0000000000000000000000021
0000000000000000000000022
0000000000000000000000023
0000000000000000000000024
0000000000000000000000025
0000000000000000000000026
0000000000000000000000027
0000000000000000000000028
0000000000000000000000029
EXPLAIN FORMAT=TREE SELECT val FROM t1 WHERE NOT EXISTS
(SELECT * FROM t2 WHERE val = 'asd' ) GROUP BY val;
EXPLAIN
-> Covering index skip scan for deduplication on t1 using ix_val  (rows=31)

SELECT val FROM t1 WHERE NOT EXISTS
(SELECT * FROM t2 WHERE val = 'asd' ) GROUP BY val;
val
0000000000000000000000000
0000000000000000000000001
0000000000000000000000002
0000000000000000000000003
0000000000000000000000004
0000000000000000000000005
0000000000000000000000006
0000000000000000000000007
0000000000000000000000008
0000000000000000000000009
0000000000000000000000010
0000000000000000000000011
0000000000000000000000012
0000000000000000000000013
0000000000000000000000014
0000000000000000000000015
0000000000000000000000016
0000000000000000000000017
0000000000000000000000018
0000000000000000000000019
0000000000000000000000020
0000000000000000000000021
0000000000000000000000022
0000000000000000000000023
0000000000000000000000024
0000000000000000000000025
0000000000000000000000026
0000000000000000000000027
0000000000000000000000028
0000000000000000000000029
# Should use group skip scan on t1
EXPLAIN FORMAT=TREE SELECT DISTINCT val FROM t1 WHERE val NOT IN (SELECT val FROM t2);
EXPLAIN
-> Nested loop antijoin  (rows=930)
    -> Covering index skip scan for deduplication on t1 using ix_val  (rows=31)
    -> Single-row index lookup on <subquery2> using <auto_distinct_key> (val=t1.val)  (rows=1)
        -> Materialize with deduplication  (rows=30)
            -> Filter: (t2.val is not null)  (rows=30)
                -> Index scan on t2 using ix_val  (rows=30)

SELECT DISTINCT val FROM t1 WHERE val NOT IN (SELECT val FROM t2);
val
0000000000000000000000000
EXPLAIN FORMAT=TREE SELECT DISTINCT val FROM t1 WHERE val NOT IN
(SELECT val FROM t2 WHERE t2.val = t1.val);
EXPLAIN
-> Nested loop antijoin  (rows=930)
    -> Covering index skip scan for deduplication on t1 using ix_val  (rows=31)
    -> Single-row index lookup on <subquery2> using <auto_distinct_key> (val=t1.val, val=t1.val)  (rows=1)
        -> Materialize with deduplication  (rows=30)
            -> Filter: ((t2.val is not null) and (t2.val is not null))  (rows=30)
                -> Index scan on t2 using ix_val  (rows=30)

Warnings:
Note	1276	Field or reference 'test.t1.val' of SELECT #2 was resolved in SELECT #1
SELECT DISTINCT val FROM t1 WHERE val NOT IN
(SELECT val FROM t2 WHERE t2.val = t1.val);
val
0000000000000000000000000
EXPLAIN FORMAT=TREE SELECT val FROM t1 WHERE val NOT IN
(SELECT val FROM t2 ) GROUP BY val;
EXPLAIN
-> Nested loop antijoin  (rows=930)
    -> Covering index skip scan for deduplication on t1 using ix_val  (rows=31)
    -> Single-row index lookup on <subquery2> using <auto_distinct_key> (val=t1.val)  (rows=1)
        -> Materialize with deduplication  (rows=30)
            -> Filter: (t2.val is not null)  (rows=30)
                -> Index scan on t2 using ix_val  (rows=30)

SELECT val FROM t1 WHERE val NOT IN
(SELECT val FROM t2 ) GROUP BY val;
val
0000000000000000000000000
EXPLAIN FORMAT=TREE SELECT val FROM t1 WHERE val NOT IN
(SELECT val FROM t2 WHERE t2.val = t1.val ) GROUP BY val;
EXPLAIN
-> Nested loop antijoin  (rows=930)
    -> Covering index skip scan for deduplication on t1 using ix_val  (rows=31)
    -> Single-row index lookup on <subquery2> using <auto_distinct_key> (val=t1.val, val=t1.val)  (rows=1)
        -> Materialize with deduplication  (rows=30)
            -> Filter: ((t2.val is not null) and (t2.val is not null))  (rows=30)
                -> Index scan on t2 using ix_val  (rows=30)

Warnings:
Note	1276	Field or reference 'test.t1.val' of SELECT #2 was resolved in SELECT #1
SELECT val FROM t1 WHERE val NOT IN
(SELECT val FROM t2 WHERE t2.val = t1.val ) GROUP BY val;
val
0000000000000000000000000
EXPLAIN FORMAT=TREE SELECT DISTINCT val FROM t1 WHERE NOT EXISTS
(SELECT * FROM t2 WHERE t2.val = t1.val);
EXPLAIN
-> Nested loop antijoin  (rows=930)
    -> Covering index skip scan for deduplication on t1 using ix_val  (rows=31)
    -> Single-row index lookup on <subquery2> using <auto_distinct_key> (val=t1.val)  (rows=1)
        -> Materialize with deduplication  (rows=30)
            -> Filter: (t2.val is not null)  (rows=30)
                -> Index scan on t2 using ix_val  (rows=30)

Warnings:
Note	1276	Field or reference 'test.t1.val' of SELECT #2 was resolved in SELECT #1
SELECT DISTINCT val FROM t1 WHERE NOT EXISTS
(SELECT * FROM t2 WHERE t2.val = t1.val);
val
0000000000000000000000000
EXPLAIN FORMAT=TREE SELECT val FROM t1 WHERE NOT EXISTS
(SELECT * FROM t2 WHERE t2.val = t1.val) GROUP BY val;
EXPLAIN
-> Nested loop antijoin  (rows=930)
    -> Covering index skip scan for deduplication on t1 using ix_val  (rows=31)
    -> Single-row index lookup on <subquery2> using <auto_distinct_key> (val=t1.val)  (rows=1)
        -> Materialize with deduplication  (rows=30)
            -> Filter: (t2.val is not null)  (rows=30)
                -> Index scan on t2 using ix_val  (rows=30)

Warnings:
Note	1276	Field or reference 'test.t1.val' of SELECT #2 was resolved in SELECT #1
SELECT val FROM t1 WHERE NOT EXISTS
(SELECT * FROM t2 WHERE t2.val = t1.val) GROUP BY val;
val
0000000000000000000000000
# Should use group skip scan on t1
EXPLAIN FORMAT=TREE SELECT DISTINCT val FROM t1 WHERE EXISTS (SELECT * FROM t2);
EXPLAIN
-> Table scan on <temporary>  (rows=31)
    -> Temporary table with deduplication  (rows=31)
        -> Inner hash join (no condition)  (rows=31)
            -> Covering index skip scan for deduplication on t1 using ix_val  (rows=31)
            -> Hash
                -> Limit: 1 row(s)  (rows=1)
                    -> Index scan on t2 using ix_val  (rows=30)

SELECT DISTINCT val FROM t1 WHERE EXISTS (SELECT * FROM t2);
val
0000000000000000000000000
0000000000000000000000001
0000000000000000000000002
0000000000000000000000003
0000000000000000000000004
0000000000000000000000005
0000000000000000000000006
0000000000000000000000007
0000000000000000000000008
0000000000000000000000009
0000000000000000000000010
0000000000000000000000011
0000000000000000000000012
0000000000000000000000013
0000000000000000000000014
0000000000000000000000015
0000000000000000000000016
0000000000000000000000017
0000000000000000000000018
0000000000000000000000019
0000000000000000000000020
0000000000000000000000021
0000000000000000000000022
0000000000000000000000023
0000000000000000000000024
0000000000000000000000025
0000000000000000000000026
0000000000000000000000027
0000000000000000000000028
0000000000000000000000029
EXPLAIN FORMAT=TREE SELECT val FROM t1 WHERE EXISTS (SELECT * FROM t2) GROUP BY val;
EXPLAIN
-> Table scan on <temporary>  (rows=31)
    -> Temporary table with deduplication  (rows=31)
        -> Inner hash join (no condition)  (rows=31)
            -> Covering index skip scan for deduplication on t1 using ix_val  (rows=31)
            -> Hash
                -> Limit: 1 row(s)  (rows=1)
                    -> Index scan on t2 using ix_val  (rows=30)

SELECT val FROM t1 WHERE EXISTS (SELECT * FROM t2) GROUP BY val;
val
0000000000000000000000000
0000000000000000000000001
0000000000000000000000002
0000000000000000000000003
0000000000000000000000004
0000000000000000000000005
0000000000000000000000006
0000000000000000000000007
0000000000000000000000008
0000000000000000000000009
0000000000000000000000010
0000000000000000000000011
0000000000000000000000012
0000000000000000000000013
0000000000000000000000014
0000000000000000000000015
0000000000000000000000016
0000000000000000000000017
0000000000000000000000018
0000000000000000000000019
0000000000000000000000020
0000000000000000000000021
0000000000000000000000022
0000000000000000000000023
0000000000000000000000024
0000000000000000000000025
0000000000000000000000026
0000000000000000000000027
0000000000000000000000028
0000000000000000000000029
# Uses group skip scan with aggregate functions since "t2" is a const
# table. Hypergraph optimizer does not support const table optimization.
# So the plan chosen is different.
EXPLAIN FORMAT=TREE SELECT val, MIN(b_id), MAX(b_id) FROM t1 WHERE NOT EXISTS
(SELECT * FROM t2 WHERE val = 'asd') GROUP BY val;
EXPLAIN
-> Covering index skip scan for grouping on t1 using ix_val  (rows=31)

SELECT val, MIN(b_id), MAX(b_id) FROM t1 WHERE NOT EXISTS
(SELECT * FROM t2 WHERE val = 'asd') GROUP BY val;
val	MIN(b_id)	MAX(b_id)
0000000000000000000000000	30	990
0000000000000000000000001	1	991
0000000000000000000000002	2	992
0000000000000000000000003	3	993
0000000000000000000000004	4	994
0000000000000000000000005	5	995
0000000000000000000000006	6	996
0000000000000000000000007	7	997
0000000000000000000000008	8	998
0000000000000000000000009	9	999
0000000000000000000000010	10	1000
0000000000000000000000011	11	971
0000000000000000000000012	12	972
0000000000000000000000013	13	973
0000000000000000000000014	14	974
0000000000000000000000015	15	975
0000000000000000000000016	16	976
0000000000000000000000017	17	977
0000000000000000000000018	18	978
0000000000000000000000019	19	979
0000000000000000000000020	20	980
0000000000000000000000021	21	981
0000000000000000000000022	22	982
0000000000000000000000023	23	983
0000000000000000000000024	24	984
0000000000000000000000025	25	985
0000000000000000000000026	26	986
0000000000000000000000027	27	987
0000000000000000000000028	28	988
0000000000000000000000029	29	989
# Should not use group skip scan on t1. Group skip scan is not supported
# on multi-table queries with aggregate functions.
EXPLAIN FORMAT=TREE SELECT val, MIN(b_id), MAX(b_id) FROM t1 WHERE val
NOT IN (SELECT val FROM t2) GROUP BY val;
EXPLAIN
-> Group aggregate: min(t1.b_id), max(t1.b_id)  (rows=30)
    -> Nested loop antijoin  (rows=30000)
        -> Index scan on t1 using ix_val  (rows=1000)
        -> Single-row index lookup on <subquery2> using <auto_distinct_key> (val=t1.val)  (rows=1)
            -> Materialize with deduplication  (rows=30)
                -> Filter: (t2.val is not null)  (rows=30)
                    -> Index scan on t2 using ix_val  (rows=30)

SELECT val, MIN(b_id), MAX(b_id) FROM t1 WHERE val
NOT IN (SELECT val FROM t2) GROUP BY val;
val	MIN(b_id)	MAX(b_id)
0000000000000000000000000	30	990
EXPLAIN FORMAT=TREE SELECT val, MIN(b_id), MAX(b_id) FROM t1 WHERE EXISTS
(SELECT * FROM t2) GROUP BY val;
EXPLAIN
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Inner hash join (no condition)  (rows=1000)
            -> Index scan on t1 using ix_val  (rows=1000)
            -> Hash
                -> Limit: 1 row(s)  (rows=1)
                    -> Index scan on t2 using ix_val  (rows=30)

SELECT val, MIN(b_id), MAX(b_id) FROM t1 WHERE EXISTS
(SELECT * FROM t2) GROUP BY val;
val	MIN(b_id)	MAX(b_id)
0000000000000000000000000	30	990
0000000000000000000000001	1	991
0000000000000000000000002	2	992
0000000000000000000000003	3	993
0000000000000000000000004	4	994
0000000000000000000000005	5	995
0000000000000000000000006	6	996
0000000000000000000000007	7	997
0000000000000000000000008	8	998
0000000000000000000000009	9	999
0000000000000000000000010	10	1000
0000000000000000000000011	11	971
0000000000000000000000012	12	972
0000000000000000000000013	13	973
0000000000000000000000014	14	974
0000000000000000000000015	15	975
0000000000000000000000016	16	976
0000000000000000000000017	17	977
0000000000000000000000018	18	978
0000000000000000000000019	19	979
0000000000000000000000020	20	980
0000000000000000000000021	21	981
0000000000000000000000022	22	982
0000000000000000000000023	23	983
0000000000000000000000024	24	984
0000000000000000000000025	25	985
0000000000000000000000026	26	986
0000000000000000000000027	27	987
0000000000000000000000028	28	988
0000000000000000000000029	29	989
# Cover nullable column scenarios
# Should use group skip scan on t1
EXPLAIN FORMAT=TREE SELECT DISTINCT val_n FROM t1 WHERE EXISTS
(SELECT * FROM t2 WHERE t2.val_n = t1.val_n);
EXPLAIN
-> Nested loop inner join  (rows=32)
    -> Filter: (t1.val_n is not null)  (rows=32)
        -> Covering index skip scan for deduplication on t1 using ix_val_n  (rows=32)
    -> Single-row covering index lookup on t2 using ix_val_n (val_n=t1.val_n)  (rows=1)

Warnings:
Note	1276	Field or reference 'test.t1.val_n' of SELECT #2 was resolved in SELECT #1
SELECT DISTINCT val_n FROM t1 WHERE EXISTS
(SELECT * FROM t2 WHERE t2.val_n = t1.val_n);
val_n
0000000000000000000000001
0000000000000000000000002
0000000000000000000000003
0000000000000000000000004
0000000000000000000000005
0000000000000000000000006
0000000000000000000000007
0000000000000000000000008
0000000000000000000000009
0000000000000000000000010
0000000000000000000000011
0000000000000000000000012
0000000000000000000000013
0000000000000000000000015
0000000000000000000000016
0000000000000000000000017
0000000000000000000000018
0000000000000000000000019
0000000000000000000000020
0000000000000000000000021
0000000000000000000000022
0000000000000000000000023
0000000000000000000000024
0000000000000000000000025
0000000000000000000000026
0000000000000000000000028
0000000000000000000000029
EXPLAIN FORMAT=TREE SELECT DISTINCT val_n FROM t1 WHERE val_n IN (SELECT val_n FROM t2);
EXPLAIN
-> Nested loop inner join  (rows=32)
    -> Filter: (t1.val_n is not null)  (rows=32)
        -> Covering index skip scan for deduplication on t1 using ix_val_n  (rows=32)
    -> Single-row covering index lookup on t2 using ix_val_n (val_n=t1.val_n)  (rows=1)

SELECT DISTINCT val_n FROM t1 WHERE val_n IN (SELECT val_n FROM t2);
val_n
0000000000000000000000001
0000000000000000000000002
0000000000000000000000003
0000000000000000000000004
0000000000000000000000005
0000000000000000000000006
0000000000000000000000007
0000000000000000000000008
0000000000000000000000009
0000000000000000000000010
0000000000000000000000011
0000000000000000000000012
0000000000000000000000013
0000000000000000000000015
0000000000000000000000016
0000000000000000000000017
0000000000000000000000018
0000000000000000000000019
0000000000000000000000020
0000000000000000000000021
0000000000000000000000022
0000000000000000000000023
0000000000000000000000024
0000000000000000000000025
0000000000000000000000026
0000000000000000000000028
0000000000000000000000029
EXPLAIN FORMAT=TREE SELECT DISTINCT val_n FROM t1 WHERE NOT EXISTS
(SELECT * FROM t2 WHERE val_n = 'asd');
EXPLAIN
-> Covering index skip scan for deduplication on t1 using ix_val_n  (rows=32)

SELECT DISTINCT val_n FROM t1 WHERE NOT EXISTS
(SELECT * FROM t2 WHERE val_n = 'asd');
val_n
NULL
0000000000000000000000000
0000000000000000000000001
0000000000000000000000002
0000000000000000000000003
0000000000000000000000004
0000000000000000000000005
0000000000000000000000006
0000000000000000000000007
0000000000000000000000008
0000000000000000000000009
0000000000000000000000010
0000000000000000000000011
0000000000000000000000012
0000000000000000000000013
0000000000000000000000014
0000000000000000000000015
0000000000000000000000016
0000000000000000000000017
0000000000000000000000018
0000000000000000000000019
0000000000000000000000020
0000000000000000000000021
0000000000000000000000022
0000000000000000000000023
0000000000000000000000024
0000000000000000000000025
0000000000000000000000026
0000000000000000000000027
0000000000000000000000028
0000000000000000000000029
# Should use group skip scan on t1
EXPLAIN FORMAT=TREE SELECT DISTINCT val_n FROM t1 WHERE val_n NOT IN
(SELECT val_n FROM t2);
EXPLAIN
-> Filter: <in_optimizer>(t1.val_n,t1.val_n in (select #2) is false)  (rows=32)
    -> Covering index skip scan for deduplication on t1 using ix_val_n  (rows=32)
    -> Select #2 (subquery in condition; run only once)
        -> Filter: ((t1.val_n = `<materialized_subquery>`.val_n))  (rows=1)
            -> Limit: 1 row(s)  (rows=1)
                -> Index lookup on <materialized_subquery> using <auto_distinct_key> (val_n=t1.val_n)
                    -> Materialize with deduplication  (rows=30)
                        -> Index scan on t2 using ix_val_n  (rows=30)

SELECT DISTINCT val_n FROM t1 WHERE val_n NOT IN
(SELECT val_n FROM t2);
val_n
EXPLAIN FORMAT=TREE SELECT DISTINCT val_n FROM t1 WHERE val_n NOT IN
(SELECT val_n FROM t2 WHERE t2.val_n = t1.val_n);
EXPLAIN
-> Filter: <in_optimizer>(t1.val_n,<exists>(select #2) is false)  (rows=32)
    -> Covering index skip scan for deduplication on t1 using ix_val_n  (rows=32)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(t2.val_n), true)  (rows=1)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.val_n) = t2.val_n) or (t2.val_n is null)), true)  (rows=1)
                    -> Single-row covering index lookup on t2 using ix_val_n (val_n=t1.val_n)  (rows=1)

Warnings:
Note	1276	Field or reference 'test.t1.val_n' of SELECT #2 was resolved in SELECT #1
SELECT DISTINCT val_n FROM t1 WHERE val_n NOT IN
(SELECT val_n FROM t2 WHERE t2.val_n = t1.val_n);
val_n
NULL
0000000000000000000000000
0000000000000000000000014
0000000000000000000000027
EXPLAIN FORMAT=TREE SELECT DISTINCT val_n FROM t1 WHERE NOT EXISTS
(SELECT * FROM t2 WHERE t2.val_n = t1.val_n);
EXPLAIN
-> Nested loop antijoin  (rows=960)
    -> Covering index skip scan for deduplication on t1 using ix_val_n  (rows=32)
    -> Single-row index lookup on <subquery2> using <auto_distinct_key> (val_n=t1.val_n)  (rows=1)
        -> Materialize with deduplication  (rows=30)
            -> Filter: (t2.val_n is not null)  (rows=30)
                -> Index scan on t2 using ix_val_n  (rows=30)

Warnings:
Note	1276	Field or reference 'test.t1.val_n' of SELECT #2 was resolved in SELECT #1
SELECT DISTINCT val_n FROM t1 WHERE NOT EXISTS
(SELECT * FROM t2 WHERE t2.val_n = t1.val_n);
val_n
NULL
0000000000000000000000000
0000000000000000000000014
0000000000000000000000027
EXPLAIN FORMAT=TREE SELECT val_n FROM t1 WHERE NOT EXISTS
(SELECT * FROM t2 WHERE t2.val_n = t1.val_n) GROUP BY val_n;
EXPLAIN
-> Nested loop antijoin  (rows=960)
    -> Covering index skip scan for deduplication on t1 using ix_val_n  (rows=32)
    -> Single-row index lookup on <subquery2> using <auto_distinct_key> (val_n=t1.val_n)  (rows=1)
        -> Materialize with deduplication  (rows=30)
            -> Filter: (t2.val_n is not null)  (rows=30)
                -> Index scan on t2 using ix_val_n  (rows=30)

Warnings:
Note	1276	Field or reference 'test.t1.val_n' of SELECT #2 was resolved in SELECT #1
SELECT val_n FROM t1 WHERE NOT EXISTS
(SELECT * FROM t2 WHERE t2.val_n = t1.val_n) GROUP BY val_n;
val_n
NULL
0000000000000000000000000
0000000000000000000000014
0000000000000000000000027
# Should use group skip scan on t1
EXPLAIN FORMAT=TREE SELECT DISTINCT val_n FROM t1 WHERE EXISTS (SELECT * FROM t2);
EXPLAIN
-> Table scan on <temporary>  (rows=32)
    -> Temporary table with deduplication  (rows=32)
        -> Inner hash join (no condition)  (rows=32)
            -> Covering index skip scan for deduplication on t1 using ix_val_n  (rows=32)
            -> Hash
                -> Limit: 1 row(s)  (rows=1)
                    -> Index scan on t2 using ix_val  (rows=30)

SELECT DISTINCT val_n FROM t1 WHERE EXISTS (SELECT * FROM t2);
val_n
NULL
0000000000000000000000000
0000000000000000000000001
0000000000000000000000002
0000000000000000000000003
0000000000000000000000004
0000000000000000000000005
0000000000000000000000006
0000000000000000000000007
0000000000000000000000008
0000000000000000000000009
0000000000000000000000010
0000000000000000000000011
0000000000000000000000012
0000000000000000000000013
0000000000000000000000014
0000000000000000000000015
0000000000000000000000016
0000000000000000000000017
0000000000000000000000018
0000000000000000000000019
0000000000000000000000020
0000000000000000000000021
0000000000000000000000022
0000000000000000000000023
0000000000000000000000024
0000000000000000000000025
0000000000000000000000026
0000000000000000000000027
0000000000000000000000028
0000000000000000000000029
# Uses group skip scan with aggregate functions since "t2" is a const
# table. Hypergraph optimizer does not support const table optimization.
# So the plan chosen is different.
EXPLAIN FORMAT=TREE SELECT val_n, MIN(b_id), MAX(b_id) FROM t1 WHERE NOT EXISTS
(SELECT * FROM t2 WHERE val_n = 'asd') GROUP BY val_n;
EXPLAIN
-> Covering index skip scan for grouping on t1 using ix_val_n  (rows=32)

SELECT val_n, MIN(b_id), MAX(b_id) FROM t1 WHERE NOT EXISTS
(SELECT * FROM t2 WHERE val_n = 'asd') GROUP BY val_n;
val_n	MIN(b_id)	MAX(b_id)
NULL	401	801
0000000000000000000000000	30	990
0000000000000000000000001	1	991
0000000000000000000000002	2	992
0000000000000000000000003	3	993
0000000000000000000000004	4	994
0000000000000000000000005	5	995
0000000000000000000000006	6	996
0000000000000000000000007	7	997
0000000000000000000000008	8	998
0000000000000000000000009	9	999
0000000000000000000000010	10	1000
0000000000000000000000011	11	971
0000000000000000000000012	12	972
0000000000000000000000013	13	973
0000000000000000000000014	14	974
0000000000000000000000015	15	975
0000000000000000000000016	16	976
0000000000000000000000017	17	977
0000000000000000000000018	18	978
0000000000000000000000019	19	979
0000000000000000000000020	20	980
0000000000000000000000021	21	981
0000000000000000000000022	22	982
0000000000000000000000023	23	983
0000000000000000000000024	24	984
0000000000000000000000025	25	985
0000000000000000000000026	26	986
0000000000000000000000027	27	987
0000000000000000000000028	28	988
0000000000000000000000029	29	989
# Should not use group skip scan on t1. Group skip scan is not supported
# on multi-table queries with aggregate functions.
EXPLAIN FORMAT=TREE SELECT val_n, MIN(b_id), MAX(b_id) FROM t1 WHERE val_n
NOT IN (SELECT val_n FROM t2) GROUP BY val_n;
EXPLAIN
-> Group aggregate: min(t1.b_id), max(t1.b_id)  (rows=31)
    -> Filter: <in_optimizer>(t1.val_n,t1.val_n in (select #2) is false)  (rows=1000)
        -> Index scan on t1 using ix_val_n  (rows=1000)
        -> Select #2 (subquery in condition; run only once)
            -> Filter: ((t1.val_n = `<materialized_subquery>`.val_n))  (rows=1)
                -> Limit: 1 row(s)  (rows=1)
                    -> Index lookup on <materialized_subquery> using <auto_distinct_key> (val_n=t1.val_n)
                        -> Materialize with deduplication  (rows=30)
                            -> Index scan on t2 using ix_val_n  (rows=30)

SELECT val_n, MIN(b_id), MAX(b_id) FROM t1 WHERE val_n
NOT IN (SELECT val_n FROM t2) GROUP BY val_n;
val_n	MIN(b_id)	MAX(b_id)
EXPLAIN FORMAT=TREE SELECT val_n, MIN(b_id), MAX(b_id) FROM t1 WHERE EXISTS
(SELECT * FROM t2) GROUP BY val_n;
EXPLAIN
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Inner hash join (no condition)  (rows=1000)
            -> Index scan on t1 using ix_val_n  (rows=1000)
            -> Hash
                -> Limit: 1 row(s)  (rows=1)
                    -> Index scan on t2 using ix_val  (rows=30)

SELECT val_n, MIN(b_id), MAX(b_id) FROM t1 WHERE EXISTS
(SELECT * FROM t2) GROUP BY val_n;
val_n	MIN(b_id)	MAX(b_id)
NULL	401	801
0000000000000000000000000	30	990
0000000000000000000000001	1	991
0000000000000000000000002	2	992
0000000000000000000000003	3	993
0000000000000000000000004	4	994
0000000000000000000000005	5	995
0000000000000000000000006	6	996
0000000000000000000000007	7	997
0000000000000000000000008	8	998
0000000000000000000000009	9	999
0000000000000000000000010	10	1000
0000000000000000000000011	11	971
0000000000000000000000012	12	972
0000000000000000000000013	13	973
0000000000000000000000014	14	974
0000000000000000000000015	15	975
0000000000000000000000016	16	976
0000000000000000000000017	17	977
0000000000000000000000018	18	978
0000000000000000000000019	19	979
0000000000000000000000020	20	980
0000000000000000000000021	21	981
0000000000000000000000022	22	982
0000000000000000000000023	23	983
0000000000000000000000024	24	984
0000000000000000000000025	25	985
0000000000000000000000026	26	986
0000000000000000000000027	27	987
0000000000000000000000028	28	988
0000000000000000000000029	29	989
DROP TABLE t1, t2;
