# MySQL 8.0 事务执行时间与长事务处理机制详解

本文档详细说明MySQL 8.0源码中关于事务执行时间管理、长事务检测以及超时处理的核心机制。

---

## 目录

1. [概述](#概述)
2. [事务时间管理](#事务时间管理)
3. [超时机制](#超时机制)
4. [长事务的影响](#长事务的影响)
5. [监控与诊断](#监控与诊断)
6. [核心源码解析](#核心源码解析)
7. [最佳实践](#最佳实践)

---

## 概述

在MySQL中，一个事务如果长时间不提交，可能会导致以下问题：
- **锁资源占用**：未提交的事务持有锁，阻塞其他事务
- **Undo空间增长**：事务越长，Undo日志越多，影响性能
- **MVCC版本链增长**：影响其他事务的读性能
- **连接资源占用**：长连接可能因超时被断开

MySQL通过多个层面的超时机制来处理这些问题。

---

## 事务时间管理

### 2.1 事务开始时间的记录

**核心结构：`trx_t::start_time`**

```cpp
// storage/innobase/include/trx0trx.h
struct trx_t {
  /** Time the state last time became TRX_STATE_ACTIVE. */
  std::atomic<std::chrono::system_clock::time_point> start_time{
      std::chrono::system_clock::time_point{}};
  static_assert(decltype(start_time)::is_always_lock_free);
  
  // ... 其他字段
};
```

**时间记录位置：**

事务开始时间在以下函数中设置：

```cpp
// storage/innobase/trx/trx0trx.cc
static void trx_start_low(trx_t *trx, bool read_write) {
  // ...
  
  // 设置事务状态为ACTIVE时，记录开始时间
  trx->state.store(TRX_STATE_ACTIVE, std::memory_order_relaxed);
  trx->start_time.store(std::chrono::system_clock::now(), 
                        std::memory_order_relaxed);
  
  // ...
}
```

**查询语句开始时间：**

```cpp
// sql/sql_class.cc
void THD::set_time() {
  start_utime = my_micro_time();
  m_lock_usec = 0;
  if (user_time.tv_sec || user_time.tv_usec)
    start_time = user_time;
  else
    my_micro_time_to_timeval(start_utime, &start_time);

#ifdef HAVE_PSI_THREAD_INTERFACE
  PSI_THREAD_CALL(set_thread_start_time)(query_start_in_secs());
#endif
}
```

### 2.2 事务状态转换

**事务状态枚举：**

```cpp
enum trx_state_t {
  TRX_STATE_NOT_STARTED,           // 未开始
  TRX_STATE_ACTIVE,                 // 活跃中
  TRX_STATE_PREPARED,               // 已准备（2PC）
  TRX_STATE_COMMITTED_IN_MEMORY,    // 已提交（内存）
  TRX_STATE_FORCED_ROLLBACK         // 强制回滚
};
```

**状态转换时机：**

1. **NOT_STARTED → ACTIVE**：第一次执行SQL语句时
2. **ACTIVE → PREPARED**：XA事务执行PREPARE时
3. **ACTIVE/PREPARED → COMMITTED_IN_MEMORY**：提交时
4. **任意状态 → FORCED_ROLLBACK**：被KILL或超时时

---

## 超时机制

MySQL有三个层次的超时机制：

### 3.1 连接层超时

#### 3.1.1 `wait_timeout` 和 `interactive_timeout`

**作用域**：连接级别  
**影响**：控制连接空闲多久后被断开

**配置变量定义：**

```cpp
// sql/sys_vars.cc

// wait_timeout: 非交互连接的超时时间
static Sys_var_ulong Sys_net_wait_timeout(
    "wait_timeout",
    "The number of seconds the server waits for activity on a "
    "connection before closing it",
    SESSION_VAR(net_wait_timeout), CMD_LINE(REQUIRED_ARG),
    VALID_RANGE(1, IF_WIN(INT_MAX32 / 1000, LONG_TIMEOUT)),
    DEFAULT(NET_WAIT_TIMEOUT), BLOCK_SIZE(1));

// interactive_timeout: 交互连接的超时时间
static Sys_var_ulong Sys_interactive_timeout(
    "interactive_timeout",
    "The number of seconds the server waits for activity on an interactive "
    "connection before closing it",
    SESSION_VAR(net_interactive_timeout), CMD_LINE(REQUIRED_ARG),
    VALID_RANGE(1, LONG_TIMEOUT), DEFAULT(NET_WAIT_TIMEOUT), BLOCK_SIZE(1));
```

**实现机制：**

```cpp
// sql/sql_parse.cc
bool do_command(THD *thd) {
  // ...
  
  /*
    This thread will do a blocking read from the client which
    will be interrupted when the next command is received from
    the client, the connection is closed or "net_wait_timeout"
    number of seconds has passed.
  */
  net = thd->get_protocol_classic()->get_net();
  my_net_set_read_timeout(net, thd->variables.net_wait_timeout);
  net_new_transaction(net);
  
  // 等待客户端命令，超时则关闭连接
  // ...
}
```

**关键点**：
- 这个超时是**连接空闲时间**，不是事务执行时间
- 超时后**整个连接被断开**，事务自动回滚
- 不会主动检测事务是否提交

### 3.2 锁等待超时

#### 3.2.1 `innodb_lock_wait_timeout`

**作用域**：InnoDB层，语句级别  
**影响**：控制等待行锁的最长时间

**核心实现：**

```cpp
// storage/innobase/lock/lock0wait.cc

void lock_wait_suspend_thread(que_thr_t *thr) {
  srv_slot_t *slot;
  trx_t *trx;
  std::chrono::steady_clock::time_point start_time;

  trx = thr_get_trx(thr);

  /* InnoDB system transactions (such as the purge, and
  incomplete transactions that are being rolled back after crash
  recovery) will use the global value of
  innodb_lock_wait_timeout, because trx->mysql_thd == NULL. */
  const auto lock_wait_timeout = trx_lock_wait_timeout_get(trx);

  lock_wait_mutex_enter();
  trx_mutex_enter(trx);

  trx->error_state = DB_SUCCESS;

  if (thr->state == QUE_THR_RUNNING) {
    /* The lock has already been released or this transaction
    was chosen as a deadlock victim: no need to suspend */

    if (trx->lock.was_chosen_as_deadlock_victim) {
      trx->error_state = DB_DEADLOCK;
      trx->lock.was_chosen_as_deadlock_victim = false;
    }

    lock_wait_mutex_exit();
    trx_mutex_exit(trx);
    return;
  }

  slot = lock_wait_table_reserve_slot(thr, lock_wait_timeout);

  if (thr->lock_state == QUE_THR_LOCK_ROW) {
    srv_stats.n_lock_wait_count.inc();
    srv_stats.n_lock_wait_current_count.inc();
    start_time = std::chrono::steady_clock::now();
  }

  lock_wait_mutex_exit();

  // ... 释放字典锁，退出InnoDB

  /* Suspend this thread and wait for the event. */
  os_event_wait(slot->event);

  // ... 唤醒后重新获取锁

  if (thr->lock_state == QUE_THR_LOCK_ROW) {
    const auto diff_time = std::chrono::steady_clock::now() - start_time;

    srv_stats.n_lock_wait_current_count.dec();
    srv_stats.n_lock_wait_time.add(
        std::chrono::duration_cast<std::chrono::microseconds>(diff_time)
            .count());

    if (diff_time > lock_sys->n_lock_max_wait_time) {
      lock_sys->n_lock_max_wait_time = diff_time;
    }

    /* Record the lock wait time for this thread */
    thd_set_lock_wait_time(trx->mysql_thd, diff_time);
  }

  /* The transaction is chosen as deadlock victim during sleep. */
  if (trx->error_state == DB_DEADLOCK) {
    return;
  }

  if (trx->error_state == DB_LOCK_WAIT_TIMEOUT) {
    MONITOR_INC(MONITOR_TIMEOUT);
  }

  if (trx_is_interrupted(trx)) {
    trx->error_state = DB_INTERRUPTED;
  }
}
```

#### 3.2.2 超时检测线程

MySQL有专门的线程定期检查锁等待超时：

```cpp
// storage/innobase/lock/lock0wait.cc

/** A thread which wakes up threads whose lock wait may have lasted too long,
analyzes wait-for-graph changes, checks for deadlocks and resolves them, and
updates schedule weights. */
void lock_wait_timeout_thread() {
  int64_t sig_count = 0;
  os_event_t event = lock_sys->timeout_event;

  ut_ad(!srv_read_only_mode);

  /** The last time we've checked for timeouts. */
  auto last_checked_for_timeouts_at = std::chrono::steady_clock::now();
  
  do {
    auto current_time = std::chrono::steady_clock::now();
    
    // 每秒检查一次超时
    if (std::chrono::seconds(1) <=
        current_time - last_checked_for_timeouts_at) {
      last_checked_for_timeouts_at = current_time;
      lock_wait_check_slots_for_timeouts();
    }

    // 更新调度权重并检查死锁
    lock_wait_update_schedule_and_check_for_deadlocks();

    /* When someone is waiting for a lock, we wake up every second (at worst)
    and check if a timeout has passed for a lock wait */
    os_event_wait_time_low(event, std::chrono::seconds{1}, sig_count);
    sig_count = os_event_reset(event);

  } while (srv_shutdown_state.load() < SRV_SHUTDOWN_CLEANUP);
}
```

**超时检查函数：**

```cpp
static void lock_wait_check_and_cancel(const srv_slot_t *slot) {
  const auto wait_time = std::chrono::steady_clock::now() - slot->suspend_time;
  
  /* Timeout exceeded or a wrap-around in system time counter */
  const auto timeout = slot->wait_timeout < std::chrono::seconds{100000000} &&
                       wait_time > slot->wait_timeout;
  trx_t *trx = thr_get_trx(slot->thr);

  if (!trx_is_interrupted(trx) && !timeout) {
    return;
  }
  
  /* 取消等待并释放线程 */
  locksys::run_if_waiting({trx}, [&]() { 
    lock_wait_try_cancel(trx, timeout); 
  });
}
```

#### 3.2.3 超时后的行为

**配置：`innodb_rollback_on_timeout`**

```cpp
// storage/innobase/row/row0mysql.cc

/** Handles user errors and lock waits detected by the database engine.
 @return true if it was a lock wait and we should continue running the
 query thread and in that case the thr is ALREADY in the running state. */
bool row_mysql_handle_errors(
    dberr_t *new_err,     /*!< out: possible new error encountered in
                          lock wait, or if no new error, the value
                          of trx->error_state at the entry of this
                          function */
    trx_t *trx,           /*!< in: transaction */
    que_thr_t *thr,       /*!< in: query thread, or NULL */
    trx_savept_t *savept) /*!< in: savepoint, or NULL */
{
  dberr_t err;

handle_new_error:
  err = trx->error_state;

  ut_a(err != DB_SUCCESS);

  trx->error_state = DB_SUCCESS;

  switch (err) {
    case DB_LOCK_WAIT_TIMEOUT:
      if (row_rollback_on_timeout) {
        trx_rollback_to_savepoint(trx, nullptr);
        break;
      }
      [[fallthrough]];
    case DB_DUPLICATE_KEY:
    // ... 其他错误
      if (savept) {
        /* Roll back the latest, possibly incomplete insertion
        or update */
        // 只回滚当前语句
        trx_rollback_to_savepoint(trx, savept);
      }
      /* MySQL will roll back the latest SQL statement */
      break;
    
    case DB_DEADLOCK:
    case DB_LOCK_TABLE_FULL:
      /* Roll back the whole transaction; this resolution was added
      to version 3.23.43 */
      trx_rollback_to_savepoint(trx, nullptr);
      break;
    // ...
  }
}
```

**行为总结：**

| 配置值 | 超时后行为 | 说明 |
|--------|-----------|------|
| `innodb_rollback_on_timeout = OFF`（默认） | 只回滚当前SQL语句 | 事务仍然保持，需要应用层决定提交或回滚 |
| `innodb_rollback_on_timeout = ON` | 回滚整个事务 | 释放所有锁，事务结束 |

### 3.3 死锁检测

死锁检测与超时检测在同一个线程中进行：

```cpp
// storage/innobase/lock/lock0wait.cc

static void lock_wait_update_schedule_and_check_for_deadlocks() {
  ut::vector<waiting_trx_info_t> infos;
  ut::vector<int> outgoing;
  ut::vector<trx_schedule_weight_t> new_weights;

  // 1. 获取等待事务的快照
  auto table_reservations = lock_wait_snapshot_waiting_threads(infos);
  
  // 2. 构建等待关系图（wait-for graph）
  lock_wait_build_wait_for_graph(infos, outgoing);

  // 3. 计算调度权重（CATS算法）
  lock_wait_compute_and_publish_weights_except_cycles(
      infos, table_reservations, outgoing, new_weights);

  // 4. 如果启用了死锁检测，查找并处理死锁
  if (innobase_deadlock_detect) {
    lock_wait_find_and_handle_deadlocks(infos, outgoing, new_weights);
  }
}
```

**死锁处理：**

```cpp
static trx_t *lock_wait_choose_victim(
    const ut::vector<uint> &cycle_ids,
    const ut::vector<waiting_trx_info_t> &infos) {
  
  ut_ad(locksys::owns_exclusive_global_latch());
  ut_ad(!cycle_ids.empty());
  
  trx_t *chosen_victim = nullptr;
  auto sorted_trxs = lock_wait_order_for_choosing_victim(cycle_ids, infos);

  for (auto *trx : sorted_trxs) {
    if (chosen_victim == nullptr) {
      chosen_victim = trx;
      continue;
    }

    // 高优先级事务处理
    if (trx_is_high_priority(chosen_victim) || trx_is_high_priority(trx)) {
      auto victim = trx_arbitrate(trx, chosen_victim);
      if (victim != nullptr) {
        if (victim == trx) {
          chosen_victim = trx;
        }
        continue;
      }
    }

    // 选择"weight"更小的事务作为victim
    // weight = undo_no + table_lock_count + lock_count
    if (trx_weight_ge(chosen_victim, trx)) {
      chosen_victim = trx;
    }
  }

  ut_a(chosen_victim);
  return chosen_victim;
}
```

---

## 长事务的影响

### 4.1 对系统的影响

#### 4.1.1 锁资源占用

长事务持有的锁会阻塞其他事务：

```sql
-- 查看当前持有锁的事务
SELECT 
    r.trx_id AS waiting_trx_id,
    r.trx_mysql_thread_id AS waiting_thread,
    r.trx_query AS waiting_query,
    b.trx_id AS blocking_trx_id,
    b.trx_mysql_thread_id AS blocking_thread,
    b.trx_query AS blocking_query,
    b.trx_state AS blocking_state,
    TIMESTAMPDIFF(SECOND, b.trx_started, NOW()) AS blocking_duration
FROM performance_schema.data_lock_waits w
JOIN information_schema.innodb_trx r ON w.requesting_engine_transaction_id = r.trx_id
JOIN information_schema.innodb_trx b ON w.blocking_engine_transaction_id = b.trx_id;
```

#### 4.1.2 Undo日志空间增长

```cpp
// storage/innobase/trx/trx0trx.cc

/** Update the transaction's latest SQL statement's start time and id. */
void trx_update_mod_tables_timestamp(trx_t *trx) {
  // 更新表的最后修改时间戳
  for (auto &table : trx->mod_tables) {
    table.first->update_time = 
        std::chrono::system_clock::to_time_t(
            std::chrono::system_clock::now());
  }
}
```

长事务产生大量Undo记录：
- 占用回滚段（Rollback Segment）空间
- 影响Purge线程清理旧版本
- 导致ibdata1文件增长

#### 4.1.3 MVCC版本链增长

```cpp
// storage/innobase/include/read0types.h

/** Read view structure for implementing MVCC */
class ReadView {
  // 读视图需要保留的最小事务ID
  trx_id_t m_low_limit_id;
  
  // 当前活跃事务列表
  ids_t m_ids;
  
  // ...
};
```

长事务会：
- 阻止Purge线程清理旧版本
- 增加版本链长度
- 降低其他事务的查询性能

---

## 监控与诊断

### 5.1 查询事务信息

#### 5.1.1 `INFORMATION_SCHEMA.INNODB_TRX`

**表结构定义：**

```cpp
// storage/innobase/include/trx0i_s.h

/** This structure represents INFORMATION_SCHEMA.innodb_trx row */
struct i_s_trx_row_t {
  trx_id_t trx_id;                  // 事务ID
  const char *trx_state;            // 事务状态：RUNNING, LOCK WAIT等
  std::chrono::system_clock::time_point trx_started;  // 事务开始时间
  const i_s_locks_row_t *requested_lock_row;          // 等待的锁
  std::chrono::system_clock::time_point trx_wait_started;  // 开始等待时间
  uintmax_t trx_weight;             // 事务权重
  std::pair<bool, trx_schedule_weight_t> trx_schedule_weight;  // 调度权重
  ulint trx_mysql_thread_id;        // MySQL线程ID
  const char *trx_query;            // 当前执行的SQL
  const CHARSET_INFO *trx_query_cs; // 查询字符集
  const char *trx_operation_state;  // 操作状态
  ulint trx_tables_in_use;          // 使用的表数量
  ulint trx_tables_locked;          // 锁定的表数量
  ulint trx_lock_structs;           // 锁结构数量
  ulint trx_lock_memory_bytes;      // 锁占用的内存
  ulint trx_rows_locked;            // 锁定的行数
  uintmax_t trx_rows_modified;      // 修改的行数
  ulint trx_concurrency_tickets;    // 并发票数
  const char *trx_isolation_level;  // 隔离级别
  bool trx_unique_checks;           // 唯一性检查
  bool trx_foreign_key_checks;      // 外键检查
  const char *trx_foreign_key_error;// 外键错误信息
  bool trx_has_search_latch;        // 是否持有搜索latch
  ulint trx_is_read_only;           // 是否只读
  ulint trx_is_autocommit_non_locking;  // 是否自动提交非锁定
};
```

**使用示例：**

```sql
-- 查看所有活跃事务
SELECT 
    trx_id,
    trx_state,
    trx_started,
    TIMESTAMPDIFF(SECOND, trx_started, NOW()) AS duration_sec,
    trx_mysql_thread_id,
    trx_query,
    trx_rows_locked,
    trx_rows_modified
FROM information_schema.innodb_trx
ORDER BY trx_started;

-- 查找长事务（运行超过60秒）
SELECT 
    trx_id,
    trx_state,
    trx_started,
    TIMESTAMPDIFF(SECOND, trx_started, NOW()) AS duration_sec,
    trx_mysql_thread_id,
    trx_query
FROM information_schema.innodb_trx
WHERE TIMESTAMPDIFF(SECOND, trx_started, NOW()) > 60
ORDER BY trx_started;

-- 查看等待锁的事务
SELECT 
    trx_id,
    trx_state,
    trx_started,
    trx_wait_started,
    TIMESTAMPDIFF(SECOND, trx_wait_started, NOW()) AS wait_duration,
    trx_mysql_thread_id,
    trx_query
FROM information_schema.innodb_trx
WHERE trx_state = 'LOCK WAIT';
```

#### 5.1.2 Performance Schema

```sql
-- 查看锁等待
SELECT 
    waiting.thread_id AS waiting_thread,
    waiting.event_name AS waiting_event,
    waiting_query.sql_text AS waiting_query,
    blocking.thread_id AS blocking_thread,
    blocking.event_name AS blocking_event,
    blocking_query.sql_text AS blocking_query
FROM performance_schema.data_lock_waits dlw
JOIN performance_schema.data_locks waiting 
    ON dlw.requesting_engine_lock_id = waiting.engine_lock_id
JOIN performance_schema.data_locks blocking 
    ON dlw.blocking_engine_lock_id = blocking.engine_lock_id
LEFT JOIN performance_schema.threads waiting_thread 
    ON waiting.thread_id = waiting_thread.thread_id
LEFT JOIN performance_schema.events_statements_current waiting_query 
    ON waiting_thread.thread_id = waiting_query.thread_id
LEFT JOIN performance_schema.threads blocking_thread 
    ON blocking.thread_id = blocking_thread.thread_id
LEFT JOIN performance_schema.events_statements_current blocking_query 
    ON blocking_thread.thread_id = blocking_query.thread_id;
```

### 5.2 监控指标

#### 5.2.1 InnoDB监控指标

```sql
-- 查看InnoDB状态
SHOW ENGINE INNODB STATUS\G

-- 关键指标：
-- TRANSACTIONS
-- ---TRANSACTION 421564789123456, ACTIVE 300 sec
-- mysql tables in use 1, locked 1
-- 1234 lock struct(s), heap size 376432, 12345 row lock(s)
```

#### 5.2.2 状态变量

```sql
-- 锁等待超时次数
SHOW STATUS LIKE 'Innodb_row_lock_time%';

-- 查看当前等待锁的事务数
SHOW STATUS LIKE 'Innodb_row_lock_current_waits';

-- 查看总的锁等待时间（毫秒）
SHOW STATUS LIKE 'Innodb_row_lock_time';

-- 查看平均锁等待时间（毫秒）
SHOW STATUS LIKE 'Innodb_row_lock_time_avg';

-- 查看最大锁等待时间（毫秒）
SHOW STATUS LIKE 'Innodb_row_lock_time_max';

-- 查看锁等待次数
SHOW STATUS LIKE 'Innodb_row_lock_waits';
```

---

## 核心源码解析

### 6.1 事务生命周期

#### 6.1.1 事务开始

```cpp
// storage/innobase/trx/trx0trx.cc

static void trx_start_low(trx_t *trx, bool read_write) {
  ut_ad(!trx->in_rollback);
  ut_ad(!trx->is_recovered);
  ut_ad(trx->start_line != 0);
  ut_ad(trx->start_file != nullptr);

  // 设置事务隔离级别
  // 初始化read view
  
  // 记录事务开始时间
  trx->start_time.store(std::chrono::system_clock::now(), 
                        std::memory_order_relaxed);

  // 根据是否为读写事务，进行不同的初始化
  if (!trx->read_only &&
      (trx->mysql_thd == nullptr || read_write || trx->ddl_operation)) {
    // 分配回滚段
    trx_assign_rseg_durable(trx);

    trx_sys_mutex_enter();

    // 分配事务ID
    trx->id = trx_sys_allocate_trx_id();

    trx_sys->rw_trx_ids.push_back(trx->id);

    // 加入到读写事务列表
    trx_add_to_rw_trx_list(trx);

    // 设置状态为ACTIVE
    trx->state.store(TRX_STATE_ACTIVE, std::memory_order_relaxed);

    trx_sys_mutex_exit();

    trx_sys_rw_trx_add(trx);

  } else {
    // 只读事务的初始化
    trx->id = 0;
    
    if (!trx_is_autocommit_non_locking(trx)) {
      if (read_write) {
        // 需要写临时表的只读事务
        trx_sys_mutex_enter();
        trx->state.store(TRX_STATE_ACTIVE, std::memory_order_relaxed);
        trx->id = trx_sys_allocate_trx_id();
        trx_sys->rw_trx_ids.push_back(trx->id);
        trx_sys_mutex_exit();
        trx_sys_rw_trx_add(trx);
      } else {
        trx->state.store(TRX_STATE_ACTIVE, std::memory_order_relaxed);
      }
    } else {
      trx->state.store(TRX_STATE_ACTIVE, std::memory_order_relaxed);
    }
  }

  ut_a(trx->error_state == DB_SUCCESS);

  MONITOR_INC(MONITOR_TRX_ACTIVE);
}
```

#### 6.1.2 事务提交

```cpp
// storage/innobase/trx/trx0trx.cc

dberr_t trx_commit_for_mysql(trx_t *trx) {
  DEBUG_SYNC_C("trx_commit_for_mysql_checks_for_aborted");
  TrxInInnoDB trx_in_innodb(trx, true);

  if (trx_in_innodb.is_aborted() &&
      trx->killed_by != std::this_thread::get_id()) {
    return (DB_FORCED_ABORT);
  }

  dberr_t db_err = DB_SUCCESS;

  ut_ad(trx_can_be_handled_by_current_thread_or_is_hp_victim(trx));

  switch (trx->state.load(std::memory_order_relaxed)) {
    case TRX_STATE_NOT_STARTED:
    case TRX_STATE_FORCED_ROLLBACK:
      trx_start_low(trx, true);
      [[fallthrough]];
    case TRX_STATE_ACTIVE:
    case TRX_STATE_PREPARED:
      trx->op_info = "committing";

      // 更新GTID
      db_err = trx_undo_gtid_add_update_undo(trx, false, false);
      if (db_err != DB_SUCCESS) {
        return (db_err);
      }

      if (trx->id != 0) {
        // 更新表的修改时间戳
        trx_update_mod_tables_timestamp(trx);
      }

      // 执行提交
      trx_commit(trx);

      MONITOR_DEC(MONITOR_TRX_ACTIVE);
      trx->op_info = "";
      return (DB_SUCCESS);
    case TRX_STATE_COMMITTED_IN_MEMORY:
      break;
  }
  ut_error;
  return (DB_CORRUPTION);
}
```

#### 6.1.3 事务回滚

```cpp
// storage/innobase/trx/trx0roll.cc

dberr_t trx_rollback_for_mysql(trx_t *trx) {
  trx->op_info = "rollback";

  // 释放表锁
  lock_trx_release_locks(trx);

  // 回滚Undo日志
  if (trx->rsegs.m_redo.rseg != nullptr && 
      trx_is_redo_rseg_updated(trx)) {
    trx_rollback_finish_undo(trx, &trx->rsegs.m_redo);
  }

  if (trx->rsegs.m_noredo.rseg != nullptr && 
      trx_is_temp_rseg_updated(trx)) {
    trx_rollback_finish_undo(trx, &trx->rsegs.m_noredo);
  }

  trx->op_info = "";

  return (DB_SUCCESS);
}
```

### 6.2 锁等待流程

```plaintext
事务执行流程（遇到锁冲突）：

1. 事务执行UPDATE/DELETE等语句
   ↓
2. row_update_for_mysql() / row_lock_table_for_mysql()
   ↓
3. 尝试获取行锁 lock_rec_lock()
   ↓
4. 发现锁冲突 → DB_LOCK_WAIT
   ↓
5. lock_wait_suspend_thread()
   - 记录等待开始时间
   - 获取超时时间配置
   - 在waiting_threads数组中预留slot
   - 线程进入等待（os_event_wait）
   ↓
6. 后台超时检测线程（每秒检查一次）
   lock_wait_timeout_thread()
   - lock_wait_check_slots_for_timeouts()
   - 检查每个slot的等待时间
   - 如果超时：lock_wait_check_and_cancel()
   ↓
7a. 未超时：其他事务释放锁 → 唤醒等待线程
    os_event_set() → 继续执行
    ↓
7b. 已超时：设置error_state = DB_LOCK_WAIT_TIMEOUT
    取消锁等待 → 回滚语句（或事务）
    ↓
8. 返回错误给MySQL层
```

### 6.3 死锁检测流程

```cpp
// storage/innobase/lock/lock0wait.cc

static void lock_wait_find_and_handle_deadlocks(
    const ut::vector<waiting_trx_info_t> &infos,
    const ut::vector<int> &outgoing,
    ut::vector<trx_schedule_weight_t> &new_weights) {
  
  const auto n = static_cast<uint>(infos.size());
  ut::vector<uint> cycle_ids;
  ut::vector<uint> colors;
  colors.resize(n, 0);
  uint current_color = 0;
  
  // DFS遍历等待图，查找环
  for (uint start = 0; start < n; ++start) {
    if (colors[start] != 0) {
      continue;
    }
    ++current_color;
    
    for (int id = start; 0 <= id; id = outgoing[id]) {
      if (colors[id] == 0) {
        // 未访问过的节点，标记颜色
        colors[id] = current_color;
        continue;
      }
      
      // 访问过的节点
      if (colors[id] == current_color) {
        // 找到环（死锁）
        lock_wait_extract_cycle_ids(cycle_ids, id, outgoing);
        
        // 验证是否真的死锁
        if (lock_wait_check_candidate_cycle(cycle_ids, infos, new_weights)) {
          MONITOR_INC(MONITOR_DEADLOCK);
        } else {
          MONITOR_INC(MONITOR_DEADLOCK_FALSE_POSITIVES);
        }
      }
      break;
    }
  }
  
  MONITOR_INC(MONITOR_DEADLOCK_ROUNDS);
  MONITOR_SET(MONITOR_LOCK_THREADS_WAITING, n);
}
```

**死锁处理流程：**

```plaintext
死锁检测与处理：

1. lock_wait_timeout_thread() 定期执行
   ↓
2. lock_wait_snapshot_waiting_threads()
   - 获取所有等待中的事务快照
   - 记录 trx → blocking_trx 的关系
   ↓
3. lock_wait_build_wait_for_graph()
   - 构建等待关系图（有向图）
   - outgoing[i] = j 表示 trx[i] 等待 trx[j]
   ↓
4. lock_wait_find_and_handle_deadlocks()
   - 使用DFS算法查找环
   - 发现环 → 可能是死锁
   ↓
5. lock_wait_check_candidate_cycle()
   - 验证环上的事务是否仍在等待
   - 防止误判（事务可能已释放）
   ↓
6. lock_wait_choose_victim()
   - 选择权重最小的事务作为victim
   - weight = undo_no + lock_count
   - 优先考虑高优先级事务（Group Replication）
   ↓
7. lock_wait_rollback_deadlock_victim()
   - 设置 was_chosen_as_deadlock_victim = true
   - 取消锁等待
   - 唤醒victim线程
   - victim返回 DB_DEADLOCK 错误
   ↓
8. victim回滚事务
   - 释放所有持有的锁
   - 其他等待的事务可以继续
```

---

## 最佳实践

### 7.1 避免长事务

**应用层面：**

1. **尽快提交事务**
   ```sql
   -- 不好的做法：
   BEGIN;
   SELECT * FROM orders WHERE user_id = 123;
   -- 进行复杂的业务逻辑处理（可能耗时很长）
   UPDATE orders SET status = 'processed' WHERE id = 456;
   COMMIT;
   
   -- 好的做法：
   -- 先查询数据，在应用层处理
   SELECT * FROM orders WHERE user_id = 123;
   -- [应用层处理逻辑]
   -- 处理完成后快速更新
   BEGIN;
   UPDATE orders SET status = 'processed' WHERE id = 456;
   COMMIT;
   ```

2. **拆分大事务**
   ```sql
   -- 不好：一次性处理10000行
   BEGIN;
   UPDATE orders SET status = 'archived' WHERE created_at < '2020-01-01';
   COMMIT;
   
   -- 好：分批处理
   -- 每次处理1000行
   WHILE (rows_affected > 0) DO
       BEGIN;
       UPDATE orders SET status = 'archived' 
       WHERE created_at < '2020-01-01' LIMIT 1000;
       COMMIT;
       -- 可以在批次之间休息，让其他事务有机会执行
   END WHILE;
   ```

3. **使用适当的隔离级别**
   ```sql
   -- 如果不需要可重复读，可以降低隔离级别
   SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
   ```

### 7.2 配置优化

**超时配置：**

```ini
[mysqld]
# 连接超时（秒）
wait_timeout = 28800                  # 8小时（默认）
interactive_timeout = 28800           # 8小时（默认）

# 锁等待超时（秒）
innodb_lock_wait_timeout = 50         # 默认50秒

# 超时是否回滚整个事务
innodb_rollback_on_timeout = OFF      # 默认OFF，只回滚语句

# 死锁检测
innodb_deadlock_detect = ON           # 默认ON

# 打印死锁信息
innodb_print_all_deadlocks = ON       # 记录到error log
```

**监控配置：**

```sql
-- 启用Performance Schema
UPDATE performance_schema.setup_instruments 
SET ENABLED = 'YES', TIMED = 'YES' 
WHERE NAME LIKE '%lock%';

UPDATE performance_schema.setup_consumers 
SET ENABLED = 'YES' 
WHERE NAME LIKE '%events%';
```

### 7.3 监控脚本示例

**查找长事务的脚本：**

```sql
-- 创建监控视图
CREATE OR REPLACE VIEW v_long_transactions AS
SELECT 
    trx_id,
    trx_state,
    trx_started,
    TIMESTAMPDIFF(SECOND, trx_started, NOW()) AS duration_sec,
    trx_mysql_thread_id,
    trx_query,
    trx_operation_state,
    trx_tables_in_use,
    trx_tables_locked,
    trx_rows_locked,
    trx_rows_modified,
    CONCAT('KILL ', trx_mysql_thread_id) AS kill_command
FROM information_schema.innodb_trx
WHERE TIMESTAMPDIFF(SECOND, trx_started, NOW()) > 60
ORDER BY trx_started;

-- 定期检查
SELECT * FROM v_long_transactions;
```

**监控锁等待：**

```sql
-- 创建锁等待监控视图
CREATE OR REPLACE VIEW v_lock_waits AS
SELECT 
    waiting_trx.trx_id AS waiting_trx_id,
    waiting_trx.trx_mysql_thread_id AS waiting_thread,
    waiting_trx.trx_query AS waiting_query,
    waiting_trx.trx_state AS waiting_state,
    TIMESTAMPDIFF(SECOND, waiting_trx.trx_wait_started, NOW()) AS wait_duration,
    blocking_trx.trx_id AS blocking_trx_id,
    blocking_trx.trx_mysql_thread_id AS blocking_thread,
    blocking_trx.trx_query AS blocking_query,
    blocking_trx.trx_state AS blocking_state,
    TIMESTAMPDIFF(SECOND, blocking_trx.trx_started, NOW()) AS blocking_duration,
    CONCAT('KILL ', blocking_trx.trx_mysql_thread_id) AS kill_blocking_command
FROM information_schema.innodb_trx AS waiting_trx
INNER JOIN performance_schema.data_lock_waits AS dlw
    ON waiting_trx.trx_id = dlw.requesting_engine_transaction_id
INNER JOIN information_schema.innodb_trx AS blocking_trx
    ON blocking_trx.trx_id = dlw.blocking_engine_transaction_id
ORDER BY wait_duration DESC;

-- 查询
SELECT * FROM v_lock_waits;
```

### 7.4 应急处理

**杀死长事务：**

```sql
-- 1. 找到长事务的线程ID
SELECT 
    trx_id,
    trx_mysql_thread_id,
    TIMESTAMPDIFF(SECOND, trx_started, NOW()) AS duration_sec,
    trx_query
FROM information_schema.innodb_trx
WHERE TIMESTAMPDIFF(SECOND, trx_started, NOW()) > 300
ORDER BY duration_sec DESC;

-- 2. 杀死线程
KILL <trx_mysql_thread_id>;

-- 或者杀死连接（会回滚事务）
KILL CONNECTION <trx_mysql_thread_id>;
```

**紧急情况下的处理：**

```sql
-- 如果系统被大量长事务阻塞：

-- 1. 设置全局变量，降低新连接的等待时间
SET GLOBAL wait_timeout = 60;
SET GLOBAL interactive_timeout = 60;
SET GLOBAL innodb_lock_wait_timeout = 10;

-- 2. 找出所有长事务并杀死
SELECT GROUP_CONCAT(
    CONCAT('KILL ', trx_mysql_thread_id, ';') 
    SEPARATOR '\n'
) AS kill_commands
FROM information_schema.innodb_trx
WHERE TIMESTAMPDIFF(SECOND, trx_started, NOW()) > 300;

-- 3. 执行生成的KILL命令

-- 4. 恢复正常配置
SET GLOBAL wait_timeout = 28800;
SET GLOBAL interactive_timeout = 28800;
SET GLOBAL innodb_lock_wait_timeout = 50;
```

---

## 相关文件索引

### 核心源码文件

| 文件路径 | 说明 |
|---------|------|
| `storage/innobase/trx/trx0trx.cc` | 事务管理核心实现 |
| `storage/innobase/lock/lock0wait.cc` | 锁等待和超时检测 |
| `storage/innobase/lock/lock0lock.cc` | 锁管理核心 |
| `storage/innobase/include/trx0trx.h` | 事务结构定义 |
| `storage/innobase/include/lock0lock.h` | 锁系统接口 |
| `storage/innobase/trx/trx0i_s.cc` | information_schema表实现 |
| `storage/innobase/handler/i_s.cc` | InnoDB information_schema插件 |
| `sql/sys_vars.cc` | 系统变量定义 |
| `sql/sql_parse.cc` | SQL解析和连接管理 |
| `sql/handler.cc` | 存储引擎接口 |

### 关键函数

| 函数名 | 文件 | 说明 |
|--------|------|------|
| `trx_start_low()` | `trx0trx.cc` | 启动事务 |
| `trx_commit()` | `trx0trx.cc` | 提交事务 |
| `lock_wait_suspend_thread()` | `lock0wait.cc` | 线程进入锁等待 |
| `lock_wait_timeout_thread()` | `lock0wait.cc` | 超时检测线程 |
| `lock_wait_check_and_cancel()` | `lock0wait.cc` | 检查并取消超时的锁等待 |
| `lock_wait_find_and_handle_deadlocks()` | `lock0wait.cc` | 死锁检测和处理 |
| `trx_lock_wait_timeout_get()` | `ha_innodb.cc` | 获取锁等待超时配置 |

### 重要数据结构

| 结构名 | 文件 | 说明 |
|--------|------|------|
| `trx_t` | `trx0trx.h` | 事务控制块 |
| `lock_t` | `lock0types.h` | 锁结构 |
| `srv_slot_t` | `srv0srv.h` | 等待槽位 |
| `i_s_trx_row_t` | `trx0i_s.h` | INNODB_TRX表行结构 |

---

## 总结

MySQL 8.0的事务时间管理和超时机制分为三个层次：

1. **连接层超时**（`wait_timeout` / `interactive_timeout`）
   - 控制连接空闲时间
   - 超时后断开连接，事务自动回滚

2. **锁等待超时**（`innodb_lock_wait_timeout`）
   - 控制等待行锁的最长时间
   - 可配置回滚行为（语句 vs 事务）

3. **死锁检测**（`innodb_deadlock_detect`）
   - 主动检测死锁并选择victim回滚
   - 使用CATS算法优化调度

**长事务的主要问题：**
- 持有锁资源，阻塞其他事务
- Undo日志空间增长
- MVCC版本链增长，影响查询性能

**监控和处理建议：**
- 定期查询 `information_schema.innodb_trx` 表
- 使用Performance Schema监控锁等待
- 设置合理的超时参数
- 应用层避免长事务，及时提交
- 紧急情况下可以KILL阻塞的线程

理解这些机制对于优化MySQL性能和处理生产环境问题至关重要。

