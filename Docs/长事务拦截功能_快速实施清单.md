# 长事务拦截功能 - 快速实施清单

本文档提供分步实施指南，帮助快速完成长事务主动拦截功能的开发。

---

## 实施步骤概览

```plaintext
阶段1：准备工作（1天）
  ├─ 代码分支准备
  ├─ 开发环境配置
  └─ 代码熟悉

阶段2：核心功能实现（3-5天）
  ├─ 步骤1：添加配置参数（0.5天）
  ├─ 步骤2：扩展事务结构（0.5天）
  ├─ 步骤3：修改事务启动逻辑（1天）
  ├─ 步骤4：实现检测线程（2天）
  └─ 步骤5：添加执行路径检查（1天）

阶段3：监控和诊断（2天）
  ├─ 步骤6：添加状态变量（0.5天）
  ├─ 步骤7：扩展INFORMATION_SCHEMA（1天）
  └─ 步骤8：添加错误消息（0.5天）

阶段4：测试和优化（3-5天）
  ├─ 步骤9：编写测试用例（2天）
  ├─ 步骤10：性能测试（1天）
  └─ 步骤11：代码审查和优化（2天）

预计总工期：9-13天
```

---

## 阶段1：准备工作

### 创建开发分支

```bash
cd /Users/baoma.xie/Desktop/mysql-server

# 创建功能分支
git checkout -b feature/trx-timeout-detection

# 确保代码最新
git pull origin master
```

### 确认开发环境

```bash
# 确认编译环境
cmake --version  # >= 3.5
gcc --version    # >= 8.0

# 确认MySQL可以正常编译
mkdir build && cd build
cmake .. -DCMAKE_BUILD_TYPE=Debug \
         -DWITH_DEBUG=1 \
         -DDOWNLOAD_BOOST=1 \
         -DWITH_BOOST=../boost
make -j$(nproc)
```

---

## 阶段2：核心功能实现

### ✅ 步骤1：添加配置参数（预计0.5天）

#### 1.1 修改 `sql/system_variables.h`

在 `System_variables` 结构中添加：

```cpp
// 文件位置：第250行左右，在 net_wait_timeout 附近
struct System_variables {
  // ... 现有变量
  ulong net_wait_timeout;
  ulong net_write_timeout;
  
  /** Transaction timeout in seconds, 0 means no timeout */
  ulong innodb_trx_timeout;  // <- 新增这一行
  
  // ... 其他变量
};
```

#### 1.2 修改 `sql/sys_vars.cc`

在文件末尾（第4900行左右）添加：

```cpp
static Sys_var_ulong Sys_innodb_trx_timeout(
    "innodb_trx_timeout",
    "Maximum time in seconds that a transaction can run before being "
    "automatically rolled back. 0 means no timeout (default).",
    SESSION_VAR(innodb_trx_timeout),
    CMD_LINE(REQUIRED_ARG),
    VALID_RANGE(0, 86400),
    DEFAULT(0),
    BLOCK_SIZE(1),
    NO_MUTEX_GUARD,
    NOT_IN_BINLOG,
    ON_CHECK(nullptr),
    ON_UPDATE(nullptr));
```

#### 1.3 验证编译

```bash
cd build
make -j$(nproc)

# 如果有编译错误，检查语法和位置
```

#### 1.4 测试配置参数

```bash
# 启动MySQL
./bin/mysqld --defaults-file=my.cnf --datadir=./data &

# 测试参数
./bin/mysql -u root -e "SELECT @@GLOBAL.innodb_trx_timeout;"
./bin/mysql -u root -e "SET SESSION innodb_trx_timeout = 300;"
./bin/mysql -u root -e "SELECT @@SESSION.innodb_trx_timeout;"
```

---

### ✅ 步骤2：扩展事务结构（预计0.5天）

#### 2.1 修改 `storage/innobase/include/trx0trx.h`

在 `trx_t` 结构中添加字段（第925行左右，`start_time` 字段后面）：

```cpp
struct trx_t {
  // ... 现有字段
  
  /** Time the state last time became TRX_STATE_ACTIVE. */
  std::atomic<std::chrono::system_clock::time_point> start_time{
      std::chrono::system_clock::time_point{}};
  static_assert(decltype(start_time)::is_always_lock_free);

  // ========== 在这里添加新字段 ==========
  
  /** Transaction timeout in seconds. 0 means no timeout. */
  std::atomic<ulong> timeout_seconds{0};
  
  /** Whether this transaction should be checked for timeout. */
  std::atomic<bool> is_timeout_check_enabled{false};
  
  /** Flag to indicate transaction has timed out. */
  std::atomic<bool> has_timed_out{false};
  
  // ========== 新字段结束 ==========

  lsn_t commit_lsn;
  // ... 其他字段
};
```

#### 2.2 初始化新字段

在 `storage/innobase/trx/trx0trx.cc` 的 `trx_init()` 函数中添加初始化：

```cpp
static void trx_init(trx_t *trx) {
  // ... 现有初始化代码
  
  trx->start_time.store(std::chrono::system_clock::time_point{},
                        std::memory_order_relaxed);
  
  // 新增初始化
  trx->timeout_seconds.store(0, std::memory_order_relaxed);
  trx->is_timeout_check_enabled.store(false, std::memory_order_relaxed);
  trx->has_timed_out.store(false, std::memory_order_relaxed);
  
  // ... 继续
}
```

---

### ✅ 步骤3：修改事务启动逻辑（预计1天）

#### 3.1 添加辅助函数

在 `storage/innobase/include/ha_prototypes.h` 中声明：

```cpp
/** Get transaction timeout from THD.
@param[in]  thd   MySQL thread handle
@return transaction timeout in seconds, 0 if no timeout */
ulong thd_get_trx_timeout(const THD *thd);
```

在 `storage/innobase/handler/ha_innodb.cc` 中实现（第16000行左右）：

```cpp
ulong thd_get_trx_timeout(const THD *thd) {
  if (thd == nullptr) {
    return 0;
  }
  return thd->variables.innodb_trx_timeout;
}
```

#### 3.2 修改 `trx_start_low()`

在 `storage/innobase/trx/trx0trx.cc` 的 `trx_start_low()` 函数中添加超时设置：

```cpp
static void trx_start_low(trx_t *trx, bool read_write) {
  // ... 现有代码
  
  trx->start_time.store(std::chrono::system_clock::now(), 
                        std::memory_order_relaxed);

  // ========== 添加超时设置 ==========
  if (trx->mysql_thd != nullptr) {
    ulong timeout = thd_get_trx_timeout(trx->mysql_thd);
    trx->timeout_seconds.store(timeout, std::memory_order_relaxed);
    
    if (timeout > 0) {
      trx->is_timeout_check_enabled.store(true, std::memory_order_relaxed);
      trx->has_timed_out.store(false, std::memory_order_relaxed);
    } else {
      trx->is_timeout_check_enabled.store(false, std::memory_order_relaxed);
    }
  }
  // ========== 超时设置结束 ==========
  
  // ... 继续原有逻辑
}
```

---

### ✅ 步骤4：实现检测线程（预计2天）

#### 4.1 添加全局变量和函数声明

在 `storage/innobase/trx/trx0trx.cc` 文件末尾添加：

```cpp
// ========== 超时检测相关全局变量 ==========

/** Global flag to signal transaction timeout check thread to stop */
static std::atomic<bool> trx_timeout_check_thread_active{false};

/** Event to wake up transaction timeout check thread */
static os_event_t trx_timeout_check_event = nullptr;

/** Counter for timed out transactions */
std::atomic<ulonglong> trx_timeout_count{0};

// ========== 检测相关函数 ==========

/** Check if a transaction has timed out.
@param[in]  trx   transaction to check
@return true if transaction has timed out */
static bool trx_check_timeout(trx_t *trx) {
  if (!trx->is_timeout_check_enabled.load(std::memory_order_relaxed)) {
    return false;
  }
  
  auto state = trx->state.load(std::memory_order_relaxed);
  if (state != TRX_STATE_ACTIVE && state != TRX_STATE_PREPARED) {
    return false;
  }
  
  if (trx->has_timed_out.load(std::memory_order_relaxed)) {
    return false;
  }
  
  auto start_time = trx->start_time.load(std::memory_order_relaxed);
  auto now = std::chrono::system_clock::now();
  auto duration = std::chrono::duration_cast<std::chrono::seconds>(
                      now - start_time).count();
  
  ulong timeout = trx->timeout_seconds.load(std::memory_order_relaxed);
  
  return (timeout > 0 && duration >= timeout);
}

/** Mark a transaction as timed out.
@param[in,out]  trx   transaction to mark as timed out */
static void trx_mark_timeout(trx_t *trx) {
  trx->has_timed_out.store(true, std::memory_order_relaxed);
  trx_timeout_count.fetch_add(1, std::memory_order_relaxed);
  
  trx_mutex_enter(trx);
  
  auto old_state = trx->state.load(std::memory_order_relaxed);
  if (old_state == TRX_STATE_ACTIVE || old_state == TRX_STATE_PREPARED) {
    trx->state.store(TRX_STATE_FORCED_ROLLBACK, std::memory_order_relaxed);
    trx->error_state = DB_FORCED_ABORT;
    
    // 记录警告日志
    ib::warn() << "Transaction " << trx_get_id_for_print(trx)
               << " has timed out after "
               << trx->timeout_seconds.load(std::memory_order_relaxed)
               << " seconds. Forcing rollback.";
    
    // 如果在等待锁，唤醒它
    if (trx->lock.que_state == TRX_QUE_LOCK_WAIT && 
        trx->lock.wait_lock != nullptr) {
      lock_cancel_waiting_and_release(trx);
    }
  }
  
  trx_mutex_exit(trx);
}

/** Transaction timeout check thread main function. */
void trx_timeout_check_thread() {
  ib::info() << "Transaction timeout check thread started";
  
  while (trx_timeout_check_thread_active.load(std::memory_order_relaxed)) {
    os_event_wait_time_low(trx_timeout_check_event, 
                           std::chrono::seconds(1), 0);
    os_event_reset(trx_timeout_check_event);
    
    if (!trx_timeout_check_thread_active.load(std::memory_order_relaxed)) {
      break;
    }
    
    // 扫描读写事务列表
    trx_sys_mutex_enter();
    
    for (auto trx : trx_sys->rw_trx_list) {
      if (trx_check_timeout(trx)) {
        trx_mark_timeout(trx);
      }
    }
    
    trx_sys_mutex_exit();
  }
  
  ib::info() << "Transaction timeout check thread stopped";
}
```

#### 4.2 在函数声明文件中添加声明

在 `storage/innobase/include/trx0trx.h` 中添加：

```cpp
// 在文件末尾，其他函数声明之后
/** Transaction timeout check thread. */
void trx_timeout_check_thread();

/** Counter for timed out transactions */
extern std::atomic<ulonglong> trx_timeout_count;
```

#### 4.3 启动和停止检测线程

修改 `storage/innobase/srv/srv0start.cc`：

```cpp
// 在 srv_start() 函数中，创建其他后台线程的地方添加：

dberr_t srv_start(bool create_new_db) {
  // ... 现有代码
  
  // 创建超时检测线程
  trx_timeout_check_event = os_event_create();
  trx_timeout_check_thread_active.store(true, std::memory_order_relaxed);
  
  os_thread_create(trx_timeout_check_thread_key, 0, 
                   trx_timeout_check_thread);
  
  ib::info() << "Transaction timeout check thread created";
  
  // ... 继续
}

// 在 srv_shutdown_all_bg_threads() 中添加：

void srv_shutdown_all_bg_threads() {
  // ... 现有停止代码
  
  // 停止超时检测线程
  if (trx_timeout_check_thread_active.load(std::memory_order_relaxed)) {
    trx_timeout_check_thread_active.store(false, std::memory_order_relaxed);
    os_event_set(trx_timeout_check_event);
    
    // 等待线程退出...
    
    os_event_destroy(trx_timeout_check_event);
    trx_timeout_check_event = nullptr;
  }
  
  // ... 继续
}
```

---

### ✅ 步骤5：添加执行路径检查（预计1天）

#### 5.1 在SQL执行入口检查超时

修改 `storage/innobase/handler/ha_innodb.cc`，在 `innobase_commit()` 函数中：

```cpp
static int innobase_commit(handlerton *hton, THD *thd, bool commit_trx) {
  trx_t *trx = check_trx_exists(thd);
  
  // ========== 添加超时检查 ==========
  if (trx->has_timed_out.load(std::memory_order_relaxed)) {
    ib::warn() << "Attempted to commit timed out transaction "
               << trx_get_id_for_print(trx) << ", forcing rollback";
    
    innobase_rollback(hton, thd, commit_trx);
    my_error(ER_LOCK_WAIT_TIMEOUT, MYF(0));  // 临时使用现有错误码
    return HA_ERR_LOCK_WAIT_TIMEOUT;
  }
  // ========== 超时检查结束 ==========
  
  // ... 原有提交逻辑
}
```

---

## 阶段3：监控和诊断

### ✅ 步骤6：添加状态变量（预计0.5天）

#### 6.1 在 `storage/innobase/handler/ha_innodb.cc` 中添加状态变量

找到 `innodb_status_variables` 数组（约第17000行），添加：

```cpp
static SHOW_VAR innodb_status_variables[] = {
  // ... 现有状态变量
  
  {"Innodb_trx_timeout_count",
   (char *)&trx_timeout_count,
   SHOW_LONGLONG,
   SHOW_SCOPE_GLOBAL},
  
  // ... 其他变量
  {NullS, NullS, SHOW_LONG, SHOW_SCOPE_GLOBAL}
};
```

#### 6.2 测试状态变量

```sql
SHOW STATUS LIKE 'Innodb_trx_timeout_count';
```

---

### ✅ 步骤7：扩展INFORMATION_SCHEMA（预计1天）

#### 7.1 修改 `storage/innobase/include/trx0i_s.h`

在 `i_s_trx_row_t` 结构中添加字段：

```cpp
struct i_s_trx_row_t {
  // ... 现有字段
  
  ulint trx_is_autocommit_non_locking;
  
  // 新增字段
  ulong trx_timeout_seconds;
  bool trx_has_timed_out;
};
```

#### 7.2 修改 `storage/innobase/handler/i_s.cc`

添加列定义：

```cpp
static ST_FIELD_INFO innodb_trx_fields_info[] = {
  // ... 现有列
  
  {"trx_timeout_seconds", MY_INT32_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONG,
   0, 0, "TRX_TIMEOUT_SECONDS", 0},
  
  {"trx_has_timed_out", 1, MYSQL_TYPE_LONG,
   0, 0, "TRX_HAS_TIMED_OUT", 0},
  
  END_OF_ST_FIELD_INFO
};
```

在数据填充函数中添加：

```cpp
// 在 trx_i_s_common_fill_table() 中
OK(fields[IDX_TRX_TIMEOUT_SECONDS]->store(
    (longlong)row->trx_timeout_seconds, true));

OK(fields[IDX_TRX_HAS_TIMED_OUT]->store(
    (longlong)row->trx_has_timed_out, true));
```

---

## 阶段4：测试和优化

### ✅ 步骤9：编写测试用例（预计2天）

#### 9.1 创建测试文件

```bash
cd mysql-test/suite/innodb/t
touch innodb_trx_timeout.test
```

#### 9.2 编写基本测试

```sql
# innodb_trx_timeout.test

--source include/have_innodb.inc

--echo # Test 1: Default value
SELECT @@GLOBAL.innodb_trx_timeout;
SELECT @@SESSION.innodb_trx_timeout;

--echo # Test 2: Set timeout
SET SESSION innodb_trx_timeout = 5;

CREATE TABLE t1 (id INT PRIMARY KEY, val INT) ENGINE=InnoDB;
INSERT INTO t1 VALUES (1, 100);

--echo # Test 3: Transaction timeout
START TRANSACTION;
UPDATE t1 SET val = 200 WHERE id = 1;
--sleep 6
--error ER_LOCK_WAIT_TIMEOUT
UPDATE t1 SET val = 300 WHERE id = 1;

--echo # Test 4: Check status
SHOW STATUS LIKE 'Innodb_trx_timeout_count';

DROP TABLE t1;
SET SESSION innodb_trx_timeout = 0;
```

#### 9.3 运行测试

```bash
cd build/mysql-test
./mtr --suite=innodb innodb_trx_timeout
```

---

### ✅ 步骤10：性能测试（预计1天）

使用sysbench进行性能测试：

```bash
# 测试1：禁用超时
mysql -e "SET GLOBAL innodb_trx_timeout = 0;"
sysbench oltp_read_write --mysql-user=root --mysql-db=test \
  --tables=10 --table-size=100000 --threads=64 --time=300 run

# 测试2：启用超时
mysql -e "SET GLOBAL innodb_trx_timeout = 300;"
sysbench oltp_read_write --mysql-user=root --mysql-db=test \
  --tables=10 --table-size=100000 --threads=64 --time=300 run

# 对比结果
```

---

## 快速验证清单

完成每个步骤后使用以下清单验证：

### □ 步骤1：配置参数
```bash
./bin/mysql -u root -e "SELECT @@innodb_trx_timeout;"
./bin/mysql -u root -e "SET SESSION innodb_trx_timeout = 60;"
```

### □ 步骤2-3：事务结构和启动
```bash
# 使用gdb调试
gdb ./bin/mysqld
(gdb) break trx_start_low
(gdb) run
# 执行BEGIN，检查trx->timeout_seconds是否正确设置
```

### □ 步骤4：检测线程
```bash
# 检查日志
grep "Transaction timeout check thread" data/error.log

# 检查进程
ps aux | grep mysqld | grep timeout
```

### □ 步骤5：执行路径检查
```sql
SET SESSION innodb_trx_timeout = 3;
BEGIN;
SELECT SLEEP(5);
COMMIT;  -- 应该失败
```

### □ 步骤6-7：监控
```sql
SHOW STATUS LIKE 'Innodb_trx_timeout_count';
SELECT * FROM information_schema.innodb_trx;
```

---

## 常见问题排查

### 编译错误

```bash
# 清理重新编译
cd build
make clean
cmake .. -DCMAKE_BUILD_TYPE=Debug
make -j$(nproc) 2>&1 | tee build.log
```

### 运行时崩溃

```bash
# 使用gdb调试
gdb --args ./bin/mysqld --defaults-file=my.cnf

# 设置断点
(gdb) break trx_timeout_check_thread
(gdb) break trx_mark_timeout
(gdb) run
```

### 测试失败

```bash
# 查看测试日志
cd mysql-test
cat var/log/innodb_trx_timeout.reject

# 重新运行单个测试
./mtr --suite=innodb innodb_trx_timeout --verbose
```

---

## 完成标志

✅ 所有测试用例通过  
✅ 性能影响 < 2%  
✅ 无内存泄漏（使用valgrind验证）  
✅ 代码审查完成  
✅ 文档更新完成  

---

## 下一步

1. 提交代码到feature分支
2. 创建Pull Request
3. 等待代码审查
4. 合并到主分支
5. 准备发布说明

---

## 联系和支持

如有问题，请参考：
- 详细设计文档：`长事务主动拦截功能设计与实现方案.md`
- 理论基础：`事务执行时间与长事务处理机制.md`
- MySQL官方文档：https://dev.mysql.com/doc/

