# MySQL长事务主动拦截功能设计与实现方案

## 目录

1. [需求背景](#需求背景)
2. [设计目标](#设计目标)
3. [功能设计](#功能设计)
4. [详细实现方案](#详细实现方案)
5. [测试方案](#测试方案)
6. [使用示例](#使用示例)
7. [注意事项](#注意事项)

---

## 需求背景

当前MySQL虽然有 `innodb_lock_wait_timeout`（锁等待超时）和 `wait_timeout`（连接空闲超时），但缺少**事务总执行时间**的超时控制。这导致：

1. **长事务无法主动终止**：事务一旦开始，只要持续有操作，就不会被超时机制检测
2. **资源长期占用**：长事务持有锁、Undo日志、MVCC版本链等资源
3. **影响系统稳定性**：大量长事务可能导致系统性能下降

### 现有超时机制的局限性

| 超时类型 | 配置项 | 作用范围 | 局限性 |
|---------|--------|---------|--------|
| 连接空闲超时 | `wait_timeout` | 连接层 | 只检测空闲时间，有活动的事务不受影响 |
| 锁等待超时 | `innodb_lock_wait_timeout` | 锁等待 | 只在等待锁时生效，获取锁后不检测 |
| 语句超时 | `max_execution_time` | 单条SQL | 无法控制整个事务的执行时间 |

**需求**：增加事务级别的超时控制，主动检测并终止超时的事务。

---

## 设计目标

### 2.1 功能目标

1. **新增配置参数**：`innodb_trx_timeout`，控制事务最长执行时间
2. **主动检测机制**：后台线程定期扫描活跃事务，检测超时
3. **灵活配置**：支持全局和会话级别配置
4. **优雅终止**：超时后回滚事务并记录日志
5. **可监控**：提供状态变量追踪超时事务数量

### 2.2 设计原则

1. **最小侵入性**：尽量复用现有机制，减少代码修改
2. **性能优先**：检测机制不应影响正常事务性能
3. **向后兼容**：默认值为0（禁用），不影响现有行为
4. **安全可靠**：确保事务一致性，不会产生脏数据

---

## 功能设计

### 3.1 整体架构

```plaintext
┌─────────────────────────────────────────────────────────────┐
│                       MySQL Server                           │
│                                                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  SQL Layer                           │   │
│  │  • 配置参数：innodb_trx_timeout (global/session)    │   │
│  │  • 状态变量：Innodb_trx_timeout_count               │   │
│  └─────────────────────────────────────────────────────┘   │
│                            │                                 │
│                            ▼                                 │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  InnoDB Layer                        │   │
│  │                                                       │   │
│  │  ┌─────────────────────────────────────────────┐   │   │
│  │  │  Transaction Management (trx0trx.cc)        │   │   │
│  │  │  • trx_t::start_time (已有)                 │   │   │
│  │  │  • trx_t::timeout_seconds (新增)            │   │   │
│  │  │  • trx_t::is_timeout_check_enabled (新增)   │   │   │
│  │  └─────────────────────────────────────────────┘   │   │
│  │                            │                         │   │
│  │                            ▼                         │   │
│  │  ┌─────────────────────────────────────────────┐   │   │
│  │  │  Timeout Detection Thread (新增)            │   │   │
│  │  │  • trx_timeout_check_thread()               │   │   │
│  │  │  • 每秒扫描活跃事务列表                      │   │   │
│  │  │  • 计算事务运行时间                          │   │   │
│  │  │  • 超时则标记事务强制回滚                    │   │   │
│  │  └─────────────────────────────────────────────┘   │   │
│  │                            │                         │   │
│  │                            ▼                         │   │
│  │  ┌─────────────────────────────────────────────┐   │   │
│  │  │  Rollback & Cleanup (trx0roll.cc)           │   │   │
│  │  │  • 回滚超时事务                              │   │   │
│  │  │  • 释放锁和资源                              │   │   │
│  │  │  • 记录错误日志                              │   │   │
│  │  └─────────────────────────────────────────────┘   │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 核心流程

```plaintext
事务生命周期中的超时检测：

1. 事务开始 (BEGIN / 第一条SQL)
   ↓
   • 记录 trx->start_time = now()
   • 读取 innodb_trx_timeout 配置
   • 设置 trx->timeout_seconds
   • 设置 trx->is_timeout_check_enabled = true
   ↓
2. 事务执行中
   ↓
   [后台线程每秒检测]
   ↓
   trx_timeout_check_thread():
   • 遍历 trx_sys->rw_trx_list (读写事务列表)
   • 对每个事务：
     - 计算运行时间 = now() - trx->start_time
     - 如果 running_time > timeout_seconds:
       ✓ 标记 trx->state = TRX_STATE_FORCED_ROLLBACK
       ✓ 设置 trx->error_state = DB_FORCED_ABORT
       ✓ 唤醒事务线程 (如果在等待)
       ✓ 记录日志和统计
   ↓
3a. 正常执行：事务提交/回滚
    ↓
    清理资源，结束
    
3b. 检测到超时：
    ↓
    • 事务下次执行SQL时检测到 FORCED_ROLLBACK
    • 自动回滚事务
    • 返回错误：ER_TRX_TIMEOUT
    • 客户端收到错误消息
```

---

## 详细实现方案

### 4.1 新增配置参数

#### 4.1.1 系统变量定义

**文件**：`sql/sys_vars.cc`

```cpp
// 在文件末尾合适位置添加

/**
  Transaction timeout in seconds. If a transaction runs longer than
  this value, it will be automatically rolled back.
  0 means no timeout (default).
*/
static Sys_var_ulong Sys_innodb_trx_timeout(
    "innodb_trx_timeout",
    "Maximum time in seconds that a transaction can run before being "
    "automatically rolled back. 0 means no timeout (default).",
    SESSION_VAR(innodb_trx_timeout),
    CMD_LINE(REQUIRED_ARG),
    VALID_RANGE(0, 86400),  // 0 ~ 24小时
    DEFAULT(0),             // 默认禁用
    BLOCK_SIZE(1),
    NO_MUTEX_GUARD,
    NOT_IN_BINLOG,
    ON_CHECK(nullptr),
    ON_UPDATE(nullptr));
```

#### 4.1.2 在THD中添加变量

**文件**：`sql/system_variables.h`

```cpp
struct System_variables {
  // ... 现有变量
  
  ulong net_read_timeout;
  ulong net_retry_count;
  ulong net_wait_timeout;
  ulong net_write_timeout;
  
  // 新增：事务超时时间（秒）
  ulong innodb_trx_timeout;
  
  // ... 其他变量
};
```

### 4.2 修改事务结构

#### 4.2.1 扩展trx_t结构

**文件**：`storage/innobase/include/trx0trx.h`

```cpp
struct trx_t {
  // ... 现有字段
  
  /** Time the state last time became TRX_STATE_ACTIVE. */
  std::atomic<std::chrono::system_clock::time_point> start_time{
      std::chrono::system_clock::time_point{}};
  static_assert(decltype(start_time)::is_always_lock_free);
  
  // ============ 新增字段 ============
  
  /** Transaction timeout in seconds. 0 means no timeout.
  Set when transaction starts from innodb_trx_timeout variable. */
  std::atomic<ulong> timeout_seconds{0};
  
  /** Whether this transaction should be checked for timeout.
  Set to true when transaction starts with timeout_seconds > 0. */
  std::atomic<bool> is_timeout_check_enabled{false};
  
  /** Flag to indicate transaction has timed out.
  Set by timeout check thread. */
  std::atomic<bool> has_timed_out{false};
  
  // ============ 新增字段结束 ============
  
  lsn_t commit_lsn; /*!< lsn at the time of the commit */
  
  // ... 其他字段
};
```

### 4.3 修改事务启动逻辑

#### 4.3.1 在事务启动时设置超时

**文件**：`storage/innobase/trx/trx0trx.cc`

```cpp
/** Start a transaction for internal processing.
@param[in,out] trx      transaction
@param[in]     read_write  true if read-write transaction */
static void trx_start_low(trx_t *trx, bool read_write) {
  ut_ad(!trx->in_rollback);
  ut_ad(!trx->is_recovered);
  ut_ad(trx->start_line != 0);
  ut_ad(trx->start_file != nullptr);

  // ... 现有代码
  
  // 记录事务开始时间
  trx->start_time.store(std::chrono::system_clock::now(), 
                        std::memory_order_relaxed);
  
  // ============ 新增代码开始 ============
  
  // 设置事务超时
  if (trx->mysql_thd != nullptr) {
    // 从THD获取超时配置
    ulong timeout = thd_get_trx_timeout(trx->mysql_thd);
    trx->timeout_seconds.store(timeout, std::memory_order_relaxed);
    
    if (timeout > 0) {
      trx->is_timeout_check_enabled.store(true, std::memory_order_relaxed);
      trx->has_timed_out.store(false, std::memory_order_relaxed);
      
      ib::info(ER_IB_MSG_TRX_TIMEOUT_SET)
          << "Transaction " << trx_get_id_for_print(trx)
          << " started with timeout " << timeout << " seconds";
    } else {
      trx->is_timeout_check_enabled.store(false, std::memory_order_relaxed);
    }
  } else {
    // 系统事务不启用超时检测
    trx->timeout_seconds.store(0, std::memory_order_relaxed);
    trx->is_timeout_check_enabled.store(false, std::memory_order_relaxed);
  }
  
  // ============ 新增代码结束 ============
  
  // ... 设置事务状态等现有代码
  
  if (!trx->read_only &&
      (trx->mysql_thd == nullptr || read_write || trx->ddl_operation)) {
    trx_assign_rseg_durable(trx);
    
    trx_sys_mutex_enter();
    trx->id = trx_sys_allocate_trx_id();
    trx_sys->rw_trx_ids.push_back(trx->id);
    trx_add_to_rw_trx_list(trx);
    trx->state.store(TRX_STATE_ACTIVE, std::memory_order_relaxed);
    trx_sys_mutex_exit();
    
    trx_sys_rw_trx_add(trx);
  } else {
    // ... 只读事务处理
  }
  
  ut_a(trx->error_state == DB_SUCCESS);
  MONITOR_INC(MONITOR_TRX_ACTIVE);
}
```

#### 4.3.2 添加辅助函数

**文件**：`storage/innobase/include/ha_prototypes.h`

```cpp
// 在文件中添加函数声明

/** Get transaction timeout from THD.
@param[in]  thd   MySQL thread handle
@return transaction timeout in seconds, 0 if no timeout */
ulong thd_get_trx_timeout(const THD *thd);
```

**文件**：`storage/innobase/handler/ha_innodb.cc`

```cpp
/** Get transaction timeout from THD.
@param[in]  thd   MySQL thread handle
@return transaction timeout in seconds, 0 if no timeout */
ulong thd_get_trx_timeout(const THD *thd) {
  if (thd == nullptr) {
    return 0;
  }
  
  return thd->variables.innodb_trx_timeout;
}
```

### 4.4 实现超时检测线程

#### 4.4.1 检测线程主函数

**文件**：`storage/innobase/trx/trx0trx.cc`

```cpp
// 在文件末尾添加

/** Global flag to signal transaction timeout check thread to stop */
static bool trx_timeout_check_thread_active = false;

/** Event to wake up transaction timeout check thread */
static os_event_t trx_timeout_check_event = nullptr;

/** Counter for timed out transactions */
static std::atomic<ulonglong> trx_timeout_count{0};

/** Check if a transaction has timed out.
@param[in,out]  trx   transaction to check
@return true if transaction has timed out */
static bool trx_check_timeout(trx_t *trx) {
  // 检查是否启用超时检测
  if (!trx->is_timeout_check_enabled.load(std::memory_order_relaxed)) {
    return false;
  }
  
  // 检查事务状态
  auto state = trx->state.load(std::memory_order_relaxed);
  if (state != TRX_STATE_ACTIVE && state != TRX_STATE_PREPARED) {
    return false;
  }
  
  // 已经标记为超时，不重复处理
  if (trx->has_timed_out.load(std::memory_order_relaxed)) {
    return false;
  }
  
  // 计算运行时间
  auto start_time = trx->start_time.load(std::memory_order_relaxed);
  auto now = std::chrono::system_clock::now();
  auto duration = std::chrono::duration_cast<std::chrono::seconds>(
                      now - start_time).count();
  
  ulong timeout = trx->timeout_seconds.load(std::memory_order_relaxed);
  
  if (timeout > 0 && duration >= timeout) {
    return true;
  }
  
  return false;
}

/** Mark a transaction as timed out and initiate rollback.
@param[in,out]  trx   transaction to mark as timed out */
static void trx_mark_timeout(trx_t *trx) {
  ut_ad(trx_check_timeout(trx));
  
  // 标记超时
  trx->has_timed_out.store(true, std::memory_order_relaxed);
  
  // 增加超时计数
  trx_timeout_count.fetch_add(1, std::memory_order_relaxed);
  
  // 获取事务互斥锁
  trx_mutex_enter(trx);
  
  // 设置强制回滚状态
  auto old_state = trx->state.load(std::memory_order_relaxed);
  if (old_state == TRX_STATE_ACTIVE || old_state == TRX_STATE_PREPARED) {
    trx->state.store(TRX_STATE_FORCED_ROLLBACK, std::memory_order_relaxed);
    trx->error_state = DB_FORCED_ABORT;
    
    // 记录日志
    ib::warn(ER_IB_MSG_TRX_TIMEOUT)
        << "Transaction " << trx_get_id_for_print(trx)
        << " (thread " << trx->mysql_thd_id
        << ") has timed out after "
        << trx->timeout_seconds.load(std::memory_order_relaxed)
        << " seconds. Forcing rollback. "
        << "Query: " << (trx->mysql_thd ? 
                         thd_query_safe(trx->mysql_thd).str : "N/A");
    
    // 如果事务正在等待锁，唤醒它
    if (trx->lock.que_state == TRX_QUE_LOCK_WAIT && 
        trx->lock.wait_lock != nullptr) {
      // 取消锁等待
      lock_cancel_waiting_and_release(trx);
    }
  }
  
  trx_mutex_exit(trx);
}

/** Transaction timeout check thread.
This thread periodically checks all active transactions and marks
timed out transactions for rollback. */
void trx_timeout_check_thread() {
  ut_ad(!srv_read_only_mode);
  
  ib::info(ER_IB_MSG_TRX_TIMEOUT_THREAD_START)
      << "Transaction timeout check thread started";
  
  while (trx_timeout_check_thread_active) {
    // 等待1秒或被唤醒
    os_event_wait_time_low(trx_timeout_check_event, 
                           std::chrono::seconds(1), 0);
    os_event_reset(trx_timeout_check_event);
    
    // 检查是否需要停止
    if (!trx_timeout_check_thread_active) {
      break;
    }
    
    // 扫描所有活跃的读写事务
    trx_sys_mutex_enter();
    
    for (auto trx : trx_sys->rw_trx_list) {
      // 检查事务是否超时
      if (trx_check_timeout(trx)) {
        // 标记超时
        trx_mark_timeout(trx);
      }
    }
    
    trx_sys_mutex_exit();
    
    // 也检查只读事务列表（如果配置了超时）
    // 注意：只读事务通常不需要超时控制，可以跳过
  }
  
  ib::info(ER_IB_MSG_TRX_TIMEOUT_THREAD_STOP)
      << "Transaction timeout check thread stopped";
}
```

#### 4.4.2 启动和停止检测线程

**文件**：`storage/innobase/srv/srv0start.cc`

在InnoDB启动时创建线程：

```cpp
/** Start the InnoDB server. */
dberr_t srv_start(bool create_new_db) {
  // ... 现有启动代码
  
  // 创建超时检测事件
  trx_timeout_check_event = os_event_create();
  
  // 启动超时检测线程
  trx_timeout_check_thread_active = true;
  
  os_thread_create(
      trx_timeout_check_thread_key,
      0,  // 线程优先级
      trx_timeout_check_thread);
  
  ib::info() << "Transaction timeout check thread created";
  
  // ... 继续启动流程
}
```

在InnoDB关闭时停止线程：

```cpp
/** Shutdown all background threads created by InnoDB. */
void srv_shutdown_all_bg_threads() {
  // ... 现有关闭代码
  
  // 停止超时检测线程
  if (trx_timeout_check_thread_active) {
    trx_timeout_check_thread_active = false;
    os_event_set(trx_timeout_check_event);
    
    // 等待线程退出
    // ... 等待逻辑
    
    os_event_destroy(trx_timeout_check_event);
    trx_timeout_check_event = nullptr;
    
    ib::info() << "Transaction timeout check thread stopped";
  }
  
  // ... 继续关闭流程
}
```

### 4.5 在事务执行路径中检查超时

#### 4.5.1 在SQL执行入口检查

**文件**：`storage/innobase/handler/ha_innodb.cc`

```cpp
/** Starts a transaction for a handle.
@param[in]  hton      handlerton
@param[in]  thd       MySQL thread handle
@param[in]  all       true for all transactions, false for autocommit
@return 0 on success */
static int innobase_start_trx_and_assign_read_view(
    handlerton *hton,
    THD *thd,
    bool all) {
  trx_t *trx = check_trx_exists(thd);
  
  // ============ 新增超时检查 ============
  // 在执行任何操作前，先检查事务是否已超时
  if (trx->has_timed_out.load(std::memory_order_relaxed)) {
    // 事务已超时，返回错误
    my_error(ER_TRX_TIMEOUT, MYF(0));
    return HA_ERR_LOCK_WAIT_TIMEOUT;
  }
  
  auto state = trx->state.load(std::memory_order_relaxed);
  if (state == TRX_STATE_FORCED_ROLLBACK) {
    // 强制回滚状态，返回错误
    my_error(ER_TRX_TIMEOUT, MYF(0));
    return HA_ERR_LOCK_WAIT_TIMEOUT;
  }
  // ============ 超时检查结束 ============
  
  // ... 原有逻辑
  
  return 0;
}

/** Execute a statement in a transaction.
@param[in]  thd       MySQL thread handle
@param[in]  all       true for all transactions
@return 0 on success */
static int innobase_commit(handlerton *hton, THD *thd, bool commit_trx) {
  trx_t *trx = check_trx_exists(thd);
  
  // ============ 新增超时检查 ============
  if (trx->has_timed_out.load(std::memory_order_relaxed)) {
    // 超时的事务不允许提交，必须回滚
    ib::warn() << "Attempted to commit timed out transaction "
               << trx_get_id_for_print(trx) << ", forcing rollback";
    
    innobase_rollback(hton, thd, commit_trx);
    my_error(ER_TRX_TIMEOUT, MYF(0));
    return HA_ERR_LOCK_WAIT_TIMEOUT;
  }
  // ============ 超时检查结束 ============
  
  // ... 原有提交逻辑
}
```

### 4.6 添加错误消息

#### 4.6.1 定义错误码

**文件**：`include/mysqld_error.h`

```cpp
// 在错误码列表中添加（找到合适的错误码编号）

#define ER_TRX_TIMEOUT 3999  // 实际编号需要按顺序分配
```

#### 4.6.2 添加错误消息

**文件**：`share/errmsg-utf8.txt`

```
ER_TRX_TIMEOUT
  eng "Transaction execution time exceeded the limit of %lu seconds and was automatically rolled back"
  chs "事务执行时间超过限制 %lu 秒，已自动回滚"
```

### 4.7 添加状态变量

#### 4.7.1 定义状态变量

**文件**：`storage/innobase/handler/ha_innodb.cc`

```cpp
// 在状态变量数组中添加

static SHOW_VAR innodb_status_variables[] = {
  // ... 现有状态变量
  
  {"Innodb_trx_timeout_count",
   (char *)&trx_timeout_count,
   SHOW_LONGLONG,
   SHOW_SCOPE_GLOBAL},
  
  // ... 其他状态变量
  
  {NullS, NullS, SHOW_LONG, SHOW_SCOPE_GLOBAL}
};
```

### 4.8 在INFORMATION_SCHEMA中显示超时信息

#### 4.8.1 扩展innodb_trx表

**文件**：`storage/innobase/include/trx0i_s.h`

```cpp
/** This structure represents INFORMATION_SCHEMA.innodb_trx row */
struct i_s_trx_row_t {
  // ... 现有字段
  
  ulint trx_is_autocommit_non_locking;
  
  // ============ 新增字段 ============
  /** Transaction timeout in seconds, 0 means no timeout */
  ulong trx_timeout_seconds;
  
  /** Whether transaction has timed out */
  bool trx_has_timed_out;
  // ============ 新增字段结束 ============
};
```

**文件**：`storage/innobase/handler/i_s.cc`

```cpp
// 添加列定义
static ST_FIELD_INFO innodb_trx_fields_info[] = {
  // ... 现有列
  
  {"trx_schedule_weight", MY_INT32_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONG,
   0, MY_I_S_MAYBE_NULL, "TRX_SCHEDULE_WEIGHT", 0},
  
  // 新增列
  {"trx_timeout_seconds", MY_INT32_NUM_DECIMAL_DIGITS, MYSQL_TYPE_LONG,
   0, 0, "TRX_TIMEOUT_SECONDS", 0},
  
  {"trx_has_timed_out", 1, MYSQL_TYPE_LONG,
   0, 0, "TRX_HAS_TIMED_OUT", 0},
  
  END_OF_ST_FIELD_INFO
};

// 在填充函数中添加数据
static int trx_i_s_common_fill_table(...) {
  // ... 现有代码
  
  // 填充超时信息
  OK(fields[IDX_TRX_TIMEOUT_SECONDS]->store(
      (longlong)row->trx_timeout_seconds, true));
  
  OK(fields[IDX_TRX_HAS_TIMED_OUT]->store(
      (longlong)row->trx_has_timed_out, true));
  
  // ... 其他代码
}
```

---

## 测试方案

### 5.1 单元测试

#### 5.1.1 基本功能测试

**测试文件**：`mysql-test/suite/innodb/t/innodb_trx_timeout.test`

```sql
--source include/have_innodb.inc

--echo #
--echo # Test innodb_trx_timeout basic functionality
--echo #

# 测试1：验证默认值为0（禁用）
SELECT @@GLOBAL.innodb_trx_timeout;
SELECT @@SESSION.innodb_trx_timeout;

# 测试2：设置全局超时
SET GLOBAL innodb_trx_timeout = 300;
SELECT @@GLOBAL.innodb_trx_timeout;

# 测试3：设置会话超时
SET SESSION innodb_trx_timeout = 10;
SELECT @@SESSION.innodb_trx_timeout;

# 测试4：超时值范围测试
--error ER_WRONG_VALUE_FOR_VAR
SET SESSION innodb_trx_timeout = -1;

--error ER_WRONG_VALUE_FOR_VAR
SET SESSION innodb_trx_timeout = 86401;  # 超过24小时

SET SESSION innodb_trx_timeout = 0;  # 应该成功
SET SESSION innodb_trx_timeout = 86400;  # 应该成功

# 恢复默认值
SET GLOBAL innodb_trx_timeout = 0;
SET SESSION innodb_trx_timeout = 0;
```

#### 5.1.2 超时功能测试

```sql
--source include/have_innodb.inc

--echo #
--echo # Test transaction timeout enforcement
--echo #

CREATE TABLE t1 (id INT PRIMARY KEY, val INT) ENGINE=InnoDB;
INSERT INTO t1 VALUES (1, 100), (2, 200), (3, 300);

# 测试5：短超时事务应该被终止
SET SESSION innodb_trx_timeout = 5;

START TRANSACTION;
UPDATE t1 SET val = 111 WHERE id = 1;

# 等待6秒，事务应该超时
--sleep 6

# 尝试继续操作，应该失败
--error ER_TRX_TIMEOUT
UPDATE t1 SET val = 222 WHERE id = 2;

# 尝试提交也应该失败
--error ER_TRX_TIMEOUT
COMMIT;

# 验证事务已回滚
SELECT * FROM t1 WHERE id = 1;  # 应该仍然是100

# 测试6：在超时前提交应该成功
SET SESSION innodb_trx_timeout = 10;

START TRANSACTION;
UPDATE t1 SET val = 111 WHERE id = 1;

# 等待3秒，未超时
--sleep 3

# 应该能成功提交
COMMIT;

# 验证提交成功
SELECT * FROM t1 WHERE id = 1;  # 应该是111

# 测试7：禁用超时（设为0）
SET SESSION innodb_trx_timeout = 0;

START TRANSACTION;
UPDATE t1 SET val = 100 WHERE id = 1;

# 即使等待很久也不会超时
--sleep 10

# 应该能成功提交
COMMIT;

# 清理
DROP TABLE t1;
SET SESSION innodb_trx_timeout = 0;
```

#### 5.1.3 并发测试

```sql
--source include/have_innodb.inc

--echo #
--echo # Test transaction timeout with concurrent transactions
--echo #

CREATE TABLE t1 (id INT PRIMARY KEY, val INT) ENGINE=InnoDB;
INSERT INTO t1 VALUES (1, 100);

# 连接1：启动长事务（会超时）
connect (con1, localhost, root,,);
SET SESSION innodb_trx_timeout = 5;
START TRANSACTION;
SELECT * FROM t1 WHERE id = 1 FOR UPDATE;

# 连接2：等待锁
connect (con2, localhost, root,,);
SET SESSION innodb_lock_wait_timeout = 20;
SET SESSION innodb_trx_timeout = 0;  # 不超时
START TRANSACTION;

# 这个语句会等待con1释放锁
# con1超时后，这里应该能获取锁
--send
UPDATE t1 SET val = 200 WHERE id = 1;

# 切回con1
connection con1;
# 等待超时
--sleep 6

# 尝试操作，应该失败（已超时）
--error ER_TRX_TIMEOUT
UPDATE t1 SET val = 300 WHERE id = 1;

# 切到con2，应该已经获取锁并成功
connection con2;
--reap
COMMIT;

# 验证结果
SELECT * FROM t1 WHERE id = 1;  # 应该是200

# 清理
connection default;
disconnect con1;
disconnect con2;
DROP TABLE t1;
```

### 5.2 性能测试

#### 5.2.1 基准测试

**测试脚本**：`benchmark_trx_timeout.sh`

```bash
#!/bin/bash

# 性能基准测试
# 比较启用和禁用超时检测的性能差异

echo "=== Transaction Timeout Performance Benchmark ==="

# 测试1：禁用超时检测
echo "Test 1: Timeout check disabled (innodb_trx_timeout=0)"
mysql -e "SET GLOBAL innodb_trx_timeout = 0;"

sysbench oltp_read_write \
  --mysql-host=127.0.0.1 \
  --mysql-user=root \
  --mysql-db=test \
  --tables=10 \
  --table-size=100000 \
  --threads=64 \
  --time=300 \
  --report-interval=10 \
  run > benchmark_disabled.log

# 测试2：启用超时检测（5分钟）
echo "Test 2: Timeout check enabled (innodb_trx_timeout=300)"
mysql -e "SET GLOBAL innodb_trx_timeout = 300;"

sysbench oltp_read_write \
  --mysql-host=127.0.0.1 \
  --mysql-user=root \
  --mysql-db=test \
  --tables=10 \
  --table-size=100000 \
  --threads=64 \
  --time=300 \
  --report-interval=10 \
  run > benchmark_enabled.log

# 比较结果
echo "=== Performance Comparison ==="
echo "Disabled:"
grep "transactions:" benchmark_disabled.log
echo "Enabled:"
grep "transactions:" benchmark_enabled.log

# 恢复默认值
mysql -e "SET GLOBAL innodb_trx_timeout = 0;"
```

### 5.3 压力测试

#### 5.3.1 大量超时事务测试

```sql
--source include/have_innodb.inc

--echo #
--echo # Stress test: many transactions timing out simultaneously
--echo #

CREATE TABLE t1 (id INT PRIMARY KEY, val INT) ENGINE=InnoDB;

# 插入测试数据
--disable_query_log
let $i = 1000;
while ($i)
{
  eval INSERT INTO t1 VALUES ($i, $i * 10);
  dec $i;
}
--enable_query_log

# 设置短超时
SET GLOBAL innodb_trx_timeout = 3;

# 启动多个并发连接，每个都会超时
let $conn = 1;
while ($conn <= 50)
{
  eval connect (con$conn, localhost, root,,);
  eval connection con$conn;
  SET SESSION innodb_trx_timeout = 3;
  START TRANSACTION;
  eval SELECT * FROM t1 WHERE id = $conn FOR UPDATE;
  inc $conn;
}

# 等待所有事务超时
--sleep 5

# 检查状态变量
connection default;
SHOW STATUS LIKE 'Innodb_trx_timeout_count';

# 清理
let $conn = 1;
while ($conn <= 50)
{
  eval disconnect con$conn;
  inc $conn;
}

DROP TABLE t1;
SET GLOBAL innodb_trx_timeout = 0;
```

---

## 使用示例

### 6.1 配置示例

#### 6.1.1 配置文件设置

**my.cnf**:

```ini
[mysqld]
# 全局默认：5分钟事务超时
innodb_trx_timeout = 300

# 其他相关配置
innodb_lock_wait_timeout = 50
wait_timeout = 28800
```

#### 6.1.2 运行时配置

```sql
-- 设置全局默认值（对新连接生效）
SET GLOBAL innodb_trx_timeout = 300;  -- 5分钟

-- 为当前会话设置
SET SESSION innodb_trx_timeout = 600;  -- 10分钟

-- 禁用超时检测
SET SESSION innodb_trx_timeout = 0;

-- 为特定业务设置短超时
SET SESSION innodb_trx_timeout = 30;  -- 30秒
```

### 6.2 监控示例

#### 6.2.1 查看超时事务统计

```sql
-- 查看超时事务总数
SHOW STATUS LIKE 'Innodb_trx_timeout_count';

-- 查看当前活跃事务及其超时配置
SELECT 
    trx_id,
    trx_state,
    trx_started,
    TIMESTAMPDIFF(SECOND, trx_started, NOW()) AS running_seconds,
    trx_timeout_seconds,
    trx_has_timed_out,
    trx_timeout_seconds - TIMESTAMPDIFF(SECOND, trx_started, NOW()) AS seconds_remaining,
    trx_mysql_thread_id,
    LEFT(trx_query, 100) AS query_preview
FROM information_schema.innodb_trx
WHERE trx_timeout_seconds > 0
ORDER BY running_seconds DESC;

-- 查找即将超时的事务（剩余时间<10%）
SELECT 
    trx_id,
    trx_started,
    TIMESTAMPDIFF(SECOND, trx_started, NOW()) AS running_seconds,
    trx_timeout_seconds,
    ROUND((trx_timeout_seconds - TIMESTAMPDIFF(SECOND, trx_started, NOW())) * 100.0 / trx_timeout_seconds, 2) AS remaining_percent,
    trx_mysql_thread_id,
    trx_query
FROM information_schema.innodb_trx
WHERE trx_timeout_seconds > 0
  AND trx_has_timed_out = 0
  AND TIMESTAMPDIFF(SECOND, trx_started, NOW()) > trx_timeout_seconds * 0.9
ORDER BY remaining_percent;
```

#### 6.2.2 监控脚本

**monitor_trx_timeout.sh**:

```bash
#!/bin/bash

# 事务超时监控脚本

MYSQL="mysql -u root -p'password' -N -s"

echo "=== Transaction Timeout Monitoring ==="
date

# 1. 超时统计
echo -e "\n[Timeout Statistics]"
$MYSQL -e "SHOW STATUS LIKE 'Innodb_trx_timeout_count';"

# 2. 当前活跃事务
echo -e "\n[Active Transactions with Timeout]"
$MYSQL -e "
SELECT 
    CONCAT('TrxID: ', trx_id, 
           ', Thread: ', trx_mysql_thread_id,
           ', Running: ', TIMESTAMPDIFF(SECOND, trx_started, NOW()), 's',
           ', Timeout: ', trx_timeout_seconds, 's',
           ', TimedOut: ', IF(trx_has_timed_out, 'YES', 'NO')
          ) AS info
FROM information_schema.innodb_trx
WHERE trx_timeout_seconds > 0
ORDER BY trx_started;
"

# 3. 即将超时的事务告警
echo -e "\n[WARNING: Transactions about to timeout (<10% remaining)]"
$MYSQL -e "
SELECT 
    CONCAT('!!! TrxID: ', trx_id,
           ', Thread: ', trx_mysql_thread_id,
           ', Running: ', TIMESTAMPDIFF(SECOND, trx_started, NOW()), 's/',
           trx_timeout_seconds, 's',
           ', Query: ', COALESCE(LEFT(trx_query, 80), 'NULL')
          ) AS warning
FROM information_schema.innodb_trx
WHERE trx_timeout_seconds > 0
  AND trx_has_timed_out = 0
  AND TIMESTAMPDIFF(SECOND, trx_started, NOW()) > trx_timeout_seconds * 0.9;
"
```

### 6.3 应用集成示例

#### 6.3.1 Python示例

```python
import mysql.connector
from mysql.connector import Error

def execute_with_timeout(connection, timeout_seconds=300):
    """执行带超时控制的事务"""
    try:
        cursor = connection.cursor()
        
        # 设置事务超时
        cursor.execute(f"SET SESSION innodb_trx_timeout = {timeout_seconds}")
        
        # 开始事务
        connection.start_transaction()
        
        # 执行业务逻辑
        cursor.execute("UPDATE orders SET status = 'processed' WHERE id = 1")
        cursor.execute("INSERT INTO order_log (order_id, action) VALUES (1, 'processed')")
        
        # 提交
        connection.commit()
        print("Transaction committed successfully")
        
    except Error as e:
        if e.errno == 3999:  # ER_TRX_TIMEOUT
            print(f"Transaction timed out after {timeout_seconds} seconds")
        else:
            print(f"Error: {e}")
        connection.rollback()
        raise

# 使用示例
try:
    conn = mysql.connector.connect(
        host='localhost',
        database='test',
        user='root',
        password='password'
    )
    
    # 执行短超时事务
    execute_with_timeout(conn, timeout_seconds=30)
    
except Error as e:
    print(f"Failed: {e}")
finally:
    if conn.is_connected():
        conn.close()
```

#### 6.3.2 Java示例

```java
import java.sql.*;

public class TransactionTimeout {
    
    public static void executeWithTimeout(Connection conn, int timeoutSeconds) 
            throws SQLException {
        Statement stmt = null;
        try {
            stmt = conn.createStatement();
            
            // 设置事务超时
            stmt.execute("SET SESSION innodb_trx_timeout = " + timeoutSeconds);
            
            // 关闭自动提交
            conn.setAutoCommit(false);
            
            // 执行业务逻辑
            stmt.executeUpdate("UPDATE orders SET status = 'processed' WHERE id = 1");
            stmt.executeUpdate("INSERT INTO order_log (order_id, action) VALUES (1, 'processed')");
            
            // 提交
            conn.commit();
            System.out.println("Transaction committed successfully");
            
        } catch (SQLException e) {
            // 检查是否是超时错误
            if (e.getErrorCode() == 3999) {  // ER_TRX_TIMEOUT
                System.err.println("Transaction timed out after " + timeoutSeconds + " seconds");
            } else {
                System.err.println("Error: " + e.getMessage());
            }
            conn.rollback();
            throw e;
        } finally {
            if (stmt != null) {
                stmt.close();
            }
            conn.setAutoCommit(true);
        }
    }
    
    public static void main(String[] args) {
        String url = "jdbc:mysql://localhost:3306/test";
        String user = "root";
        String password = "password";
        
        try (Connection conn = DriverManager.getConnection(url, user, password)) {
            // 执行带超时的事务
            executeWithTimeout(conn, 30);  // 30秒超时
            
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```

---

## 注意事项

### 7.1 性能影响

#### 7.1.1 检测开销

- **CPU开销**：后台线程每秒扫描一次事务列表
  - 对于少量事务（<1000）：开销可忽略
  - 对于大量事务（>10000）：可能有1-2%的CPU开销
  
- **内存开销**：每个事务增加约16字节（3个新字段）
  
- **锁竞争**：需要获取 `trx_sys_mutex`
  - 检测频率为1秒，影响很小
  - 与现有死锁检测共享同一互斥锁

#### 7.1.2 优化建议

```cpp
// 可以考虑的优化：只扫描启用了超时检测的事务

static void trx_timeout_check_thread() {
  // ...
  
  // 优化：维护一个单独的超时事务列表
  // 避免扫描所有事务
  std::vector<trx_t*> timeout_enabled_trxs;
  
  trx_sys_mutex_enter();
  for (auto trx : trx_sys->rw_trx_list) {
    if (trx->is_timeout_check_enabled.load(std::memory_order_relaxed)) {
      timeout_enabled_trxs.push_back(trx);
    }
  }
  trx_sys_mutex_exit();
  
  // 只检查启用了超时的事务
  for (auto trx : timeout_enabled_trxs) {
    if (trx_check_timeout(trx)) {
      trx_mark_timeout(trx);
    }
  }
  
  // ...
}
```

### 7.2 兼容性考虑

#### 7.2.1 升级兼容性

- **默认值为0**：不影响现有行为
- **配置持久化**：如果使用 `SET PERSIST`，升级前需要注意
- **主从复制**：
  - 主库设置超时，从库也应该设置
  - binlog中不记录超时配置（NOT_IN_BINLOG）
  - 超时回滚会记录到binlog，从库正常回放

#### 7.2.2 与其他功能的交互

- **XA事务**：
  - PREPARED状态的XA事务也会被检测
  - 超时后需要手动 `XA ROLLBACK`
  
- **复制**：
  - 应用线程的超时由 `innodb_trx_timeout` 控制
  - 建议主从使用相同配置
  
- **Group Replication**：
  - 高优先级事务（HP事务）不应被超时机制影响
  - 需要在检测逻辑中排除

```cpp
static bool trx_check_timeout(trx_t *trx) {
  // ... 现有检查
  
  // 排除高优先级事务
  if (trx_is_high_priority(trx)) {
    return false;
  }
  
  // ... 继续检查
}
```

### 7.3 故障排查

#### 7.3.1 常见问题

**问题1**：事务意外超时

```sql
-- 检查超时配置
SELECT @@SESSION.innodb_trx_timeout;

-- 查看事务运行时间
SELECT 
    trx_id,
    TIMESTAMPDIFF(SECOND, trx_started, NOW()) AS running_seconds,
    trx_timeout_seconds
FROM information_schema.innodb_trx
WHERE trx_mysql_thread_id = CONNECTION_ID();
```

**问题2**：检测线程未运行

```bash
# 检查错误日志
grep "Transaction timeout check thread" error.log

# 检查进程
ps aux | grep mysqld
```

**问题3**：超时后事务未回滚

```sql
-- 检查事务状态
SELECT 
    trx_id,
    trx_state,
    trx_has_timed_out,
    trx_operation_state
FROM information_schema.innodb_trx
WHERE trx_has_timed_out = 1;

-- 手动终止
KILL <thread_id>;
```

#### 7.3.2 调试信息

在源码中添加调试日志：

```cpp
// 在 trx_mark_timeout() 中
ib::info() << "[TRX_TIMEOUT_DEBUG] Transaction " << trx->id
           << " marked as timed out."
           << " Start time: " << trx->start_time
           << " Timeout: " << trx->timeout_seconds
           << " State: " << trx->state
           << " Query: " << (trx->mysql_thd ? 
                            thd_query_safe(trx->mysql_thd).str : "N/A");
```

### 7.4 安全性考虑

#### 7.4.1 权限控制

```sql
-- 只有SUPER权限才能设置全局值
GRANT SUPER ON *.* TO 'admin'@'%';

-- 普通用户可以设置会话值
GRANT SELECT, INSERT, UPDATE, DELETE ON mydb.* TO 'user'@'%';
```

#### 7.4.2 防止滥用

```sql
-- 限制最大超时时间（在代码中实现）
VALID_RANGE(0, 86400)  -- 最多24小时

-- 建议在应用层也做限制
SET SESSION innodb_trx_timeout = LEAST(@user_timeout, 3600);
```

---

## 总结

本方案实现了MySQL事务级别的超时控制功能，主要特点：

### 关键技术点

1. **非侵入式设计**：复用现有的事务管理和回滚机制
2. **高效检测**：后台线程定期扫描，开销小
3. **灵活配置**：支持全局和会话级别
4. **完整监控**：通过状态变量和INFORMATION_SCHEMA表监控

### 实施步骤

1. **第一阶段**：核心功能实现
   - 添加配置参数和变量
   - 实现检测线程
   - 修改事务结构和启动逻辑

2. **第二阶段**：监控和日志
   - 添加状态变量
   - 扩展INFORMATION_SCHEMA表
   - 完善错误消息

3. **第三阶段**：测试和优化
   - 单元测试
   - 性能测试
   - 压力测试
   - 性能优化

### 预期效果

- **防止长事务**：自动终止运行时间过长的事务
- **保护系统**：减少资源占用，提高系统稳定性
- **可观测性**：提供完整的监控和诊断手段
- **灵活可控**：根据业务需求灵活配置

### 下一步工作

1. 完成代码实现和编译测试
2. 执行完整的测试用例
3. 性能基准测试和优化
4. 编写用户文档
5. 准备发布和部署

---

## 参考资料

- [MySQL InnoDB事务管理](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-management.html)
- [InnoDB锁机制](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html)
- [INFORMATION_SCHEMA INNODB_TRX表](https://dev.mysql.com/doc/refman/8.0/en/information-schema-innodb-trx-table.html)
- 本项目已有文档：`事务执行时间与长事务处理机制.md`

