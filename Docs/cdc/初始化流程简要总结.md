# CDC 初始化流程简要总结

## 核心流程（5个阶段）

### 阶段一：程序启动 (main.go)
```
启动 → 解析命令行 → 创建根Context → prepareEnv() → 执行子命令
```

### 阶段二：环境准备 (prepareEnv)
这是最关键的初始化阶段，按顺序执行18个步骤：

| 步骤 | 组件 | 作用 |
|------|------|------|
| 1 | Config | 加载并验证配置参数 |
| 2-3 | Signal Handler | 监听退出信号，支持优雅关闭 |
| 4 | Metrics | 注册 Prometheus 监控指标 |
| 5 | Confirm Window | 初始化消息确认窗口（保证可靠性） |
| 6 | Web Service | 启动 HTTP 服务（端口 7082） |
| 7 | Table Match Rules | 加载表过滤和路由规则 |
| 8 | **Throttler** | 初始化节流器（内存、速率、带宽） |
| 9 | **Message Queue** | 初始化消息队列（冲突检测用） |
| 10 | **Metadata Service** | 打开元数据服务（存储位点、状态等） |
| 11 | User Rules | 加载自定义转换规则 |
| 12-14 | Background Tasks | 启动后台任务（监控、资源收集等） |

### 阶段三：Dump 服务初始化 (source.StartDump)

#### 3.1 创建 Dump 实例
```go
NewDumpInstance()
  → 创建数据库连接 (instance.NewInstance)
  → 设置连接池大小
  → 初始化内部数据结构
```

#### 3.2 预检查 (PrepareCheck)
```go
VerifyVariables()
  → 检查 binlog_row_value_options (必须为空)
  → 检查 binlog_row_metadata (必须为 MINIMAL)
  → 检查 binlog_encryption (必须为 OFF)
  → 检查 binlog_transaction_compression (必须为 OFF)
  → 检查 sql_generate_invisible_primary_key (必须为 OFF)
```
**任何一项不符合要求，初始化立即失败！**

#### 3.3 准备运行环境 (PrepareRunningEnv)
```go
1. 确定起始位点 (startPos)：
   - 从元数据读取上次保存的 GTID 位点
   - 或使用配置指定的位点
   - 或从头开始 (ChangePosFromScratch)

2. 确定停止位点 (stopPos)：
   - 解析 GTID Set
   - 或指定停止时间

3. 初始化流式环境：
   - 保存位点和时间信息
   - 获取源数据库的 report_host 和 hostname
   - 启动网络延迟监控 (定时 ping)
```

#### 3.4 加载表信息 (ShowTables)
```go
LoadAllTables()
  → 根据过滤规则获取需要同步的表列表
  → 统计表数量
  → 获取外键引用关系 (GetForeignReferMap)
  → 更新监控指标
```

#### 3.5 执行 Dump (Run)

**两种模式：**

**A. CDC 模式**（仅增量）
```
获取当前最新 GTID → 直接开始 StreamDump (读 binlog)
```

**B. 普通模式**（全量 + 增量）
```
1. 设置状态为 FULL
2. 加载/记录初始 GTID 位点
3. 清理旧的表结构缓存
4. 设置外键引用关系
5. 执行全量 BatchDump
   → 并发读取表数据
   → 分批次发送到本地队列
6. 等待全量完成（约90秒）
7. 设置状态为 INCR
8. 开始 StreamDump (读 binlog)
   → 从记录的 GTID 位点开始
   → 持续接收 binlog 事件
   → 解析并发送到本地队列
```

### 阶段四：Apply 服务初始化 (sink.StartApply)

#### 4.1 创建 Applier
```go
根据 worker 数量选择模式：
  - workerNum <= 1 → SimpleApplier (单线程)
  - workerNum > 1 → DAGApplier (多线程 DAG 引擎)
```

#### 4.2 创建 Sinker
```go
根据目标类型创建不同的 Sinker：
  - MySQL/OceanBase → apply_mysql/apply_ob
  - ClickHouse → apply_warehouse
  - PostgreSQL → apply_postgres
  - Redis → apply_redis
  - Elasticsearch → apply_es
  - ...
```

#### 4.3 初始化 Sinker
```go
sinker.Initialize(ctx)
  → 创建目标数据库连接
  → 初始化连接池
  → 加载目标表结构
  → 准备 SQL 语句模板
```

#### 4.4 运行 Applier
```go
SimpleApplier.Run():
  Loop:
    1. 从 LocalQueue 消费消息
    2. 添加到 ConfirmWindow
    3. 执行 sinker.Execute()
       → 将消息转换为 SQL
       → 批量执行 INSERT/UPDATE/DELETE
       → 处理 DDL（独占模式）
    4. 确认消息

DAGApplier.Run():
  Loop:
    1. 从 LocalQueue 消费消息
    2. 检查是否需要独占执行（DDL）
    3. 将消息投递到 DAG 引擎
    4. 引擎并发执行（多个 worker）
```

### 阶段五：Sync 模式启动 (execSync)
```go
1. go sink.StartApply(ctx)   // 启动消费者
2. go trigger.DoTriggerMessage(ctx)  // 启动触发器
3. source.StartDump(ctx)       // 启动生产者（阻塞主线程）
```

---

## 与源数据库交互时序

```
1. 建立连接
   ↓
2. 验证配置 (VerifyVariables)
   - SHOW VARIABLES LIKE 'binlog_%'
   - SHOW VARIABLES LIKE 'sql_generate_%'
   ↓
3. 获取元信息
   - SHOW VARIABLES LIKE 'version'
   - SHOW MASTER STATUS / SHOW BINARY LOG STATUS
   - SHOW VARIABLES LIKE 'report_host'
   - SHOW VARIABLES LIKE 'hostname'
   ↓
4. 加载表列表
   - SHOW TABLES FROM database
   - SELECT ... FROM information_schema.TABLES
   - SELECT ... FROM information_schema.KEY_COLUMN_USAGE (外键)
   ↓
5. 全量阶段（如果需要）
   - 记录起始 GTID
   - SELECT * FROM table LIMIT batch_size
   - 多表并发读取
   ↓
6. 增量阶段
   - 通过 MySQL 复制协议连接
   - COM_BINLOG_DUMP_GTID
   - 从指定 GTID 开始订阅
   - 持续接收 binlog 事件流
```

---

## 数据流转路径

```
┌─────────────┐
│  Source DB  │ MySQL
└──────┬──────┘
       │ (1) Binlog Replication Protocol
       ↓
┌─────────────────────┐
│  StreamDump/        │ 读取并解析 binlog
│  BatchDump          │
└──────┬──────────────┘
       │ (2) DataMessage
       ↓
┌─────────────────────┐
│  LocalQueue         │ 内存队列（解耦生产消费）
│  (cache_queue)      │
└──────┬──────────────┘
       │ (3) Consume
       ↓
┌─────────────────────┐
│  Applier            │ SimpleApplier / DAGApplier
│  (sink)             │
└──────┬──────────────┘
       │ (4) Execute
       ↓
┌─────────────────────┐
│  Sinker             │ 根据目标类型执行
│  (apply_*)          │
└──────┬──────────────┘
       │ (5) SQL / API
       ↓
┌─────────────┐
│  Target DB  │ MySQL/PG/ClickHouse/Redis/...
└─────────────┘

       并行路径：
       ↓
┌─────────────────────┐
│  ConfirmWindow      │ 追踪消息处理状态
└──────┬──────────────┘
       │ (6) Ack
       ↓
┌─────────────────────┐
│  Metadata Service   │ 保存已确认的 GTID 位点
└─────────────────────┘
```

---

## 关键数据结构

### DataMessage
```go
type DataMessage struct {
    XID           string        // GTID (事务 ID)
    MessageType   MessageType   // MessageBatch / MessageStream
    SchemaName    string        // 数据库名
    TableName     string        // 表名
    Action        Action        // INSERT/UPDATE/DELETE
    Columns       []Column      // 列信息
    Rows          [][]interface{} // 数据行
    BatchNumber   int64         // 批次号
    InFullStage   bool          // 是否在全量阶段
    ConfirmInfo   *ConfirmInfo  // 确认信息
}
```

### ConfirmWindow
```go
- 维护待确认消息列表
- 按 GTID 顺序确认
- 只有确认的消息才会推进位点
- 支持消息超时重试
```

### Metadata Service
```go
// 保存的关键信息：
- change_pos/{job}/{task}          // 当前 GTID 位点
- init_start_pos/{job}/{task}      // 初始 GTID 位点
- change_pos_confirm/{job}/{task}  // 已确认的 GTID 位点
- table_schema/{service}/{region}/{namespace}/{task}  // 表结构
- task_status/{job}/{task}         // 任务状态 (FULL/INCR/FINISH/ERROR)
- pod_ip/{job}/{task}              // 服务 IP 和端口
```

---

## 初始化检查清单

### 必须满足的条件

**源数据库（MySQL）：**
- [ ] binlog_format = ROW
- [ ] binlog_row_metadata = MINIMAL
- [ ] binlog_row_value_options = '' (空)
- [ ] binlog_encryption = OFF
- [ ] binlog_transaction_compression = OFF
- [ ] sql_generate_invisible_primary_key = OFF
- [ ] 用户有 REPLICATION SLAVE, REPLICATION CLIENT 权限

**元数据服务：**
- [ ] etcd/consul/mysql/redis 可访问
- [ ] 用户有读写权限

**网络：**
- [ ] 源数据库可连接
- [ ] 目标数据库可连接
- [ ] 元数据服务可连接
- [ ] 消息队列可连接（如果启用）

**资源：**
- [ ] 内存足够（max_memory_mb 配置合理）
- [ ] 磁盘空间足够（日志目录）
- [ ] CPU 足够（并发 worker 数量）

---

## 常见初始化失败原因

| 错误信息 | 原因 | 解决方案 |
|---------|------|---------|
| `not support binlog_row_value_options open` | MySQL 开启了不支持的特性 | 关闭 binlog_row_value_options |
| `not support binlog_encryption open` | binlog 加密已开启 | 关闭 binlog_encryption |
| `open metadata service failed` | 无法连接元数据服务 | 检查 metadata_server 配置和网络 |
| `parse change position failed` | GTID 格式错误 | 清理元数据或指定正确的 start_pos |
| `invalid dump instance type` | 不支持的 dumper 类型 | 检查 source_type 配置 |
| `build 'xxx' sinker failed` | 无法创建目标 sinker | 检查 sink_type 和目标数据库连接 |

---

## 监控与观测

### 关键指标
```
# 同步延迟
cdc_message_delay_seconds

# 同步速率
cdc_message_counter_source{stage="dump"}
cdc_message_counter_sink{stage="apply"}

# 表同步进度
cdc_sync_table_num
cdc_full_total_table_num
cdc_full_finish_table_num

# 内存使用
cdc_memory_usage_bytes

# 网络延迟
cdc_source_network_delay_ms
```

### HTTP 接口（默认端口 7082）
```
GET /status          # 查看任务状态
GET /metrics         # Prometheus 指标
GET /gtid            # 查看当前 GTID
GET /tables          # 查看同步表列表
POST /append_table   # 动态添加表
```

---

## 总结

CDC 初始化的核心目标：
1. ✅ **建立稳定连接**：与源数据库、目标数据库、元数据服务
2. ✅ **验证环境配置**：确保 MySQL 配置符合要求
3. ✅ **确定同步位点**：从哪里开始，到哪里结束
4. ✅ **加载表信息**：哪些表需要同步，表结构是什么
5. ✅ **启动核心服务**：Dump（生产）、Apply（消费）
6. ✅ **保证可靠性**：位点保存、消息确认、错误恢复

初始化完成后，系统进入稳定运行状态：
- Dump 持续读取 binlog 事件
- Apply 持续应用到目标数据库
- Metadata 定期保存位点
- Monitor 持续上报指标

整个设计充分考虑了生产环境的复杂性和可靠性要求！

